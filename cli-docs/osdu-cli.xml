This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
osducli/
  auth/
    __init__.py
    aws_token_credential.py
    credentials.py
    msal_interactive.py
    msal_non_interactive.py
    token_credential.py
  commands/
    config/
      __init__.py
      consts.py
      default.py
      info.py
      list.py
      update.py
    crs/
      __init__.py
      _const.py
      areas.py
      info.py
      list.py
      summary.py
      transforms.py
    dataload/
      __init__.py
      checkrefs.py
      ingest.py
      status.py
      verify.py
    entitlements/
      groups/
        __init__.py
        add.py
        delete.py
        members.py
      members/
        __init__.py
        add.py
        groups.py
        list.py
        remove.py
      __init__.py
      _const.py
      info.py
      mygroups.py
    file/
      __init__.py
      _const.py
      download.py
      info.py
      metadata.py
    legal/
      __init__.py
      _const.py
      add.py
      delete.py
      info.py
      listtags.py
    list/
      __init__.py
      records.py
    schema/
      __init__.py
      _const.py
      add.py
      get.py
      info.py
      list.py
    search/
      __init__.py
      _const.py
      id.py
      info.py
      kind.py
      query.py
    status/
      __init__.py
      status.py
    storage/
      __init__.py
      _const.py
      add.py
      delete.py
      get.py
      info.py
      list.py
      versions.py
    unit/
      __init__.py
      _const.py
      info.py
      list.py
    version/
      __init__.py
      version.py
    wellbore_ddms/
      well_log/
        data/
          __init__.py
          add.py
          get.py
        __init__.py
        add.py
        get.py
      __init__.py
      _const.py
      info.py
    workflow/
      __init__.py
      _const.py
      get.py
      info.py
      list.py
      register.py
      runs.py
      status.py
      unregister.py
    __init__.py
  util/
    __init__.py
    exceptions.py
    file.py
    prompt.py
    pypi.py
    service_info.py
  __init__.py
  __main__.py
  click_cli.py
  cliclient.py
  config.py
  log.py
  state.py
  wbddms_client.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="osducli/auth/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
</file>

<file path="osducli/auth/aws_token_credential.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import base64
import json

import requests
from osdu_api.providers.types import BaseCredentials
from requests import HTTPError

from osducli.log import get_logger

logger = get_logger(__name__)


class AwsTokenCredential(BaseCredentials):
    """AWS token based client for connecting with OSDU."""

    __access_token = None

    def __init__(
            self,
            client_id: str,
            client_secret: str,
            token_url: str,
            oauth_custom_scope: str,
    ):
        super().__init__()
        self._client_id = client_id
        self._client_secret = client_secret
        self._token_url = token_url
        self._oauth_custom_scope = oauth_custom_scope

    @property
    def access_token(self) -> str:
        return self.__access_token

    def refresh_token(self) -> str:
        self.__access_token = self._get_service_principal_token()
        return self.__access_token

    def _get_service_principal_token(self) -> str:
        auth = f'{self._client_id}:{self._client_secret}'
        encoded_auth = base64.b64encode(str.encode(auth))

        headers = {
            'Authorization': 'Basic ' + encoded_auth.decode(),
            'Content-Type': 'application/x-www-form-urlencoded'
        }

        data = {
            "grant_type": "client_credentials",
            "scope": self._oauth_custom_scope
        }
        try:
            response = requests.post(url=self._token_url, headers=headers, data=data, timeout=10)
            return json.loads(response.content.decode())['access_token']
        except HTTPError as ex:
            code = ex.response.status_code
            message = ex.response.content.decode()
            logger.error("Refresh token request failed. %s %s", code, message)
            raise
</file>

<file path="osducli/auth/credentials.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
"""Credentials functions."""

import os

from osdu_api.providers.types import BaseCredentials

from osducli.auth.aws_token_credential import AwsTokenCredential
from osducli.auth.msal_interactive import MsalInteractiveCredential
from osducli.auth.msal_non_interactive import MsalNonInteractiveCredential
from osducli.auth.token_credential import TokenCredential
from osducli.config import (
    CLI_CONFIG_DIR,
    CONFIG_AUTHENTICATION_AUTHORITY,
    CONFIG_AUTHENTICATION_SCOPES,
    CONFIG_CLIENT_ID,
    CONFIG_CLIENT_SECRET,
    CONFIG_REFRESH_TOKEN,
    CONFIG_TOKEN_ENDPOINT,
)


def aws_token_credentials(config) -> BaseCredentials:
    """Credentials for AWS"""
    client_id = config.get("core", CONFIG_CLIENT_ID)
    client_secret = config.get("core", CONFIG_CLIENT_SECRET, None)
    token_endpoint = config.get("core", CONFIG_AUTHENTICATION_AUTHORITY, None)
    scopes = config.get("core", CONFIG_AUTHENTICATION_SCOPES, None)
    credentials = AwsTokenCredential(client_id, client_secret, token_endpoint, scopes)
    return credentials


def msal_non_interactive_credentials(config) -> BaseCredentials:
    """Credentials for Azure using MSAL non-interactive"""
    client_id = config.get("core", CONFIG_CLIENT_ID)
    authority = config.get("core", CONFIG_AUTHENTICATION_AUTHORITY, None)
    scopes = config.get("core", CONFIG_AUTHENTICATION_SCOPES, None)
    client_secret = config.get("core", CONFIG_CLIENT_SECRET, None)
    credentials = MsalNonInteractiveCredential(
        client_id=client_id,
        client_secret=client_secret,
        authority=authority,
        scopes=scopes,
    )
    return credentials


def msal_interactive_credentials(config) -> BaseCredentials:
    """Credentials for Azure using MSAL interactive"""
    client_id = config.get("core", CONFIG_CLIENT_ID)
    authority = config.get("core", CONFIG_AUTHENTICATION_AUTHORITY, None)
    scopes = config.get("core", CONFIG_AUTHENTICATION_SCOPES, None)
    cache_path = os.path.join(CLI_CONFIG_DIR, "msal_token_cache.bin")
    credentials = MsalInteractiveCredential(
        client_id, authority, scopes, cache_path
    )
    return credentials


def refresh_token_credentials(config) -> BaseCredentials:
    """Credentials for Azure using refresh token"""
    client_id = config.get("core", CONFIG_CLIENT_ID)
    token_endpoint = config.get("core", CONFIG_TOKEN_ENDPOINT, None)
    refresh_token = config.get("core", CONFIG_REFRESH_TOKEN, None)
    client_secret = config.get("core", CONFIG_CLIENT_SECRET, None)
    credentials = TokenCredential(
        client_id, token_endpoint, refresh_token, client_secret
    )
    return credentials
</file>

<file path="osducli/auth/msal_interactive.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import os

import msal
from osdu_api.providers.types import BaseCredentials

from osducli.log import get_logger

logger = get_logger(__name__)


class MsalInteractiveCredential(BaseCredentials):
    """Refresh token based client for connecting with OSDU."""

    __access_token = None

    def __init__(self, client_id: str, authority: str, scopes: str, token_cache: str = None):
        """Setup the new client

        Args:
            client_id (str): client id for connecting
            authority (str): authority url
            scopes (str): scopes to request
            token_cache (str): path to persist tokens to
        """
        super().__init__()
        self._client_id = client_id
        self._authority = authority
        self._scopes = scopes
        self._token_cache = token_cache

    @property
    def access_token(self) -> str:
        return self.__access_token

    def _refresh_access_token(self) -> dict:
        """Refresh token using msal.

        Returns:
            dict: Dictionary representing the returned token
        """

        # Create a preferably long-lived app instance which maintains a persistant token cache.
        cache = msal.SerializableTokenCache()
        if os.path.exists(self._token_cache):
            with open(self._token_cache, encoding="utf8") as cachefile:
                cache.deserialize(cachefile.read())

        app = msal.PublicClientApplication(
            self._client_id, authority=self._authority, token_cache=cache
        )

        result = None

        # Firstly, check the cache to see if this end user has signed in before
        # accounts = app.get_accounts(username=config.get("username"))
        accounts = app.get_accounts()
        if accounts:
            logger.debug("Account(s) exists in cache, probably with token too. Let's try.")
            # for a in accounts:
            #     print(a["username"])
            chosen = accounts[
                0
            ]  # Assuming the end user chose this one to proceed - should change if multiple
            # Now let's try to find a token in cache for this account
            result = app.acquire_token_silent([self._scopes], account=chosen)

        if not result:
            logger.debug("No suitable token exists in cache. Let's get a new one from AAD.")
            print("A local browser window will be open for you to sign in. CTRL+C to cancel.")
            result = app.acquire_token_interactive(
                [self._scopes],
                timeout=10,
                # login_hint=config.get("username"),  # Optional.
                # If you know the username ahead of time, this parameter can pre-fill
                # the username (or email address) field of the sign-in page for the user,
                # Often, apps use this parameter during reauthentication,
                # after already extracting the username from an earlier sign-in
                # by using the preferred_username claim from returned id_token_claims.
                # Or simply "select_account" as below - Optional. It forces to show account selector page
                prompt=msal.Prompt.SELECT_ACCOUNT,
            )

            if cache.has_state_changed:
                with open(self._token_cache, "w", encoding="utf8") as cachefile:
                    cachefile.write(cache.serialize())

        return result

    def refresh_token(self) -> str:
        result = self._refresh_access_token()

        if "access_token" in result:
            self.__access_token = result["access_token"]
        else:
            logger.error(result.get("error"))
            logger.error(result.get("error_description"))
            logger.error(result.get("correlation_id"))

        return self.__access_token
</file>

<file path="osducli/auth/msal_non_interactive.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from msal import ConfidentialClientApplication
from osdu_api.providers.types import BaseCredentials

from osducli.log import get_logger

logger = get_logger(__name__)


class MsalNonInteractiveCredential(BaseCredentials):
    """Get token based client for connecting with OSDU."""

    _access_token = None

    def __init__(self,
                 client_id: str,
                 client_secret: str,
                 authority: str,
                 scopes: str):
        """Setup the new client

        Args:
            client_id (str): client id for connecting
            authority (str): authority url
            scopes (str): scopes to request
        """
        super().__init__()
        self._client_id = client_id
        self._client_secret = client_secret
        self._authority = authority
        self._scopes = scopes
        self._app = ConfidentialClientApplication(
            self._client_id, self._client_secret, self._authority
        )

    @property
    def access_token(self) -> str:
        return self._access_token

    def refresh_token(self) -> str:
        """
        return access_token.
        """
        response = self._app.acquire_token_for_client(scopes=[self._scopes])
        if 'access_token' in response:
            self._access_token = response['access_token']
        else:
            raise Exception("Failed to aquire token")

        return self._access_token
</file>

<file path="osducli/auth/token_credential.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from datetime import datetime
from json import loads
from urllib.error import HTTPError
from urllib.parse import urlencode
from urllib.request import Request, urlopen

from osdu_api.providers.types import BaseCredentials

from osducli.log import get_logger

logger = get_logger(__name__)


class TokenCredential(BaseCredentials):
    """Refresh token based client for connecting with OSDU."""

    __access_token_expire_date = 0
    __access_token = None

    def __init__(
        self,
        client_id: str,
        token_endpoint: str,
        refresh_token: str,
        client_secret: str,
    ):
        """Setup the new client

        Args:
            client_id (str): client id for connecting
            token_endpoint (str): token endpoint for refreshing token
            refresh_token (str): refresh token
            client_secret (str): client secret
        """
        super().__init__()
        self._client_id = client_id
        self._token_endpoint = token_endpoint
        self._refresh_token = refresh_token
        self._client_secret = client_secret

    @property
    def access_token(self) -> str:
        """
        Check expiration date and return access_token.
        """
        if datetime.now().timestamp() > self.__access_token_expire_date:
            self.refresh_token()
        return self.__access_token

    def _refresh_access_token(self) -> dict:
        """
        Send refresh token requests to OpenID token endpoint.

        Return dict with keys "access_token", "expires_in", "scope", "token_type", "id_token".
        """
        body = {
            "grant_type": "refresh_token",
            "refresh_token": self._refresh_token,
            "client_id": self._client_id,
            "client_secret": self._client_secret,
        }
        headers = {"Content-Type": "application/x-www-form-urlencoded"}
        data = urlencode(body).encode("utf8")
        request = Request(url=self._token_endpoint, data=data, headers=headers)
        try:
            with urlopen(request) as response:
                response_body = response.read()
                return loads(response_body)
        except HTTPError as ex:
            code = ex.code
            message = ex.read().decode("utf8")
            logger.error("Refresh token request failed. %s %s", code, message)
            raise

    def refresh_token(self) -> str:
        """Refresh from refresh token.

        Returns:
            dict: Dictionary representing the returned token
        """
        result = self._refresh_access_token()

        if "access_token" in result:
            self.__access_token = result["access_token"]
            self.__access_token_expire_date = datetime.now().timestamp() + result["expires_in"]

        else:
            print(result.get("error"))
            print(result.get("error_description"))
            print(result.get("correlation_id"))

        return self.__access_token
</file>

<file path="osducli/commands/config/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Config commands"""
</file>

<file path="osducli/commands/config/consts.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Constants for config commands"""

AUTHENTICATION_LIST = [
    {
        "name": "refresh_token",
        "desc": "Provide a refresh token that is used to get an access token",
    },
    {"name": "msal_interactive", "desc": "Azure interactive authentication."},
    {"name": "msal_non_interactive", "desc": "Azure non interactive authentication."},
]

MSG_INTRO = (
    "\nWelcome to the OSDU CLI! This command will guide you through setting some default values.\n"
)
MSG_CLOSING = (
    "\nYou're all set! Here are some commands to try:\n $ osdu status\n $ osdu list records\n"
)

MSG_GLOBAL_SETTINGS_LOCATION = "Your settings can be found at {}"

MSG_HEADING_CURRENT_CONFIG_INFO = "Your current configuration is as follows:"
MSG_HEADING_ENV_VARS = "\nEnvironment variables:"

MSG_PROMPT_CONFIG = "\nWhat config file do you want to use as the default?"
MSG_PROMPT_MANAGE_GLOBAL = "\nDo you wish to change your settings?"
MSG_PROMPT_SERVER = "\nOSDU API Server []: "
MSG_PROMPT_CRS_CATALOG_URL = "\nCRS Catalog API path []: "
MSG_PROMPT_CRS_CONVERTER_URL = "\nCRS Converter API path []: "
MSG_PROMPT_CONFIG_ENTITLEMENTS_URL = "\nEntitlements API path []: "
MSG_PROMPT_FILE_URL = "\nFile API path []: "
MSG_PROMPT_LEGAL_URL = "\nLegal API path []: "
MSG_PROMPT_SCHEMA_URL = "\nSchema API path []: "
MSG_PROMPT_SEARCH_URL = "\nSearch API path []: "
MSG_PROMPT_STORAGE_URL = "\nStorage API path []: "
MSG_PROMPT_UNIT_URL = "\nUnit API path []: "
MSG_PROMPT_WELLBORE_DDMS_URL = "\nWellbore DDMS API path []: "
MSG_PROMPT_WORKFLOW_URL = "\nWorkflow API path []: "

MSG_PROMPT_DATA_PARTITION = "\nData partition name []: "
MSG_PROMPT_LEGAL_TAG = "\nManifest legal tag []: "
MSG_PROMPT_ACL_VIEWER = "\nacl viewer []: "
MSG_PROMPT_ACL_OWNER = "\nacl owner []: "

MSG_PROMPT_AUTHENTICATION_MODE = "\nHow will you authenticate?"
MSG_PROMPT_AUTHORITY = "\nAuthority []: "
MSG_PROMPT_SCOPES = "\nScopes []: "
MSG_PROMPT_TOKEN_ENDPOINT_URL = "\nAuthentication token endpoint url []: "
MSG_PROMPT_REFRESH_TOKEN = "\nRefresh token []: "
MSG_PROMPT_CLIENT_ID = "\nClient id []: "
MSG_PROMPT_CLIENT_SECRET = "\nClient secret []: "
</file>

<file path="osducli/commands/config/default.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""config default command"""
import os.path
from pathlib import Path

import click

from osducli.click_cli import CustomClickCommand, State, global_params
from osducli.cliclient import handle_cli_exceptions
from osducli.state import get_default_config_path, set_default_config_path
from osducli.util.prompt import prompt


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@global_params
def _click_command(state: State):
    """Set the default config file"""
    config_default(state)


def config_default(state: State):
    """Set the default config file

    Args:
        state (State): Global state
    """
    config_file = get_default_config_path()
    default_config_file = get_default_config_path(locate=True)

    if config_file:
        print(f"Currently using '{config_file}'")
    elif default_config_file:
        print(f"Currently using default config '{default_config_file}'")

    if state.config_path is None:
        config_file = prompt("What config file should be the default: ")
    else:
        config_file = state.config_path

    if config_file:
        if Path(config_file).is_file():
            print(f"Setting default config to: '{config_file}'")
            set_default_config_path(config_file)
        else:
            config_file = state.config.config_dir + os.path.sep + config_file
            if Path(config_file).is_file():
                print(f"Setting default config to: '{config_file}'")
                set_default_config_path(config_file)
            else:
                print("The specified file was not found. Run osdu config update to add configuration values.")
    else:
        print("No changes made!")
</file>

<file path="osducli/commands/config/info.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Config info command"""

import os

import click

from osducli.click_cli import CustomClickCommand, global_params
from osducli.cliclient import handle_cli_exceptions
from osducli.commands.config.consts import (
    MSG_HEADING_CURRENT_CONFIG_INFO,
    MSG_HEADING_ENV_VARS,
)
from osducli.config import CLI_ENV_VAR_PREFIX, CLIConfig


@click.command(cls=CustomClickCommand)
@global_params
@handle_cli_exceptions
def _click_command(state):
    # def _click_command(ctx, debug, config, hostname):
    """Configuration info"""
    config_info(state)


def print_cur_configuration(cli_config: CLIConfig):
    """Print the current configuration

    Args:
        cli_config (CLIConfig): CLIConfig
    """

    print("TODO: accesses config_parser file directly - might show actual used values instead")
    print(MSG_HEADING_CURRENT_CONFIG_INFO)
    if cli_config.config_parser:
        for section in cli_config.config_parser.sections():
            print()
            print(f"[{section}]")
            for name, value in cli_config.config_parser.items(section):
                print(f"{name} = {value}")
        env_vars = [ev for ev in os.environ if ev.startswith(CLI_ENV_VAR_PREFIX)]
        if env_vars:
            print(MSG_HEADING_ENV_VARS)
            print("\n".join([f"{ev} = {os.environ[ev]}" for ev in env_vars]))
    else:
        print(f"No config file found at {cli_config.config_path}. run osdcli ")
        print("Try running 'osdcli config update' or 'osdcli config set'")


def config_info(state):
    """Show configuration

    Args:
        state (State): Global state
    """
    print_cur_configuration(state.config)
</file>

<file path="osducli/commands/config/list.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Config list command"""

import os

import click

from osducli.click_cli import CustomClickCommand, global_params
from osducli.cliclient import handle_cli_exceptions
from osducli.config import CLIConfig


@click.command(cls=CustomClickCommand)
@global_params
@handle_cli_exceptions
def _click_command(state):
    # def _click_command(ctx, debug, config, hostname):
    """List available configurations"""
    config_list(state)


def list_configurations(cli_config: CLIConfig):
    """List the configurations

    Args:
        cli_config (CLIConfig): CLIConfig
    """
    if os.path.exists(cli_config.config_dir):
        try:
            files = os.listdir(cli_config.config_dir)
            if files:
                print(f"Configuration files available in {cli_config.config_dir}:")
                list_config_files(cli_config.config_file_name, files)
            else:
                warn_config_missing(cli_config.config_dir)
        except OSError:
            warn_config_missing(cli_config.config_dir)


def list_config_files(current_filename: str, files: list[str]):
    """List configuration files"""
    for file in files:
        if file not in ("state", "msal_token_cache.bin"):
            if file == current_filename:
                print(file + "  <== (Currently using)")
            else:
                print(file)


def warn_config_missing(config_dir: str):
    """Warn missing configuration"""
    print(f"No config file found at {config_dir}.")
    print("Try running 'osdu config update' or 'osdu config set'")


def config_list(state):
    """List configurations

    Args:
        state (State): Global state
    """
    list_configurations(state.config)
</file>

<file path="osducli/commands/config/update.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Config update command"""

import configparser

import click

from osducli.click_cli import CustomClickCommand, State, global_params
from osducli.cliclient import handle_cli_exceptions
from osducli.commands.config.consts import (
    AUTHENTICATION_LIST,
    MSG_CLOSING,
    MSG_GLOBAL_SETTINGS_LOCATION,
    MSG_INTRO,
    MSG_PROMPT_ACL_OWNER,
    MSG_PROMPT_ACL_VIEWER,
    MSG_PROMPT_AUTHENTICATION_MODE,
    MSG_PROMPT_AUTHORITY,
    MSG_PROMPT_CLIENT_ID,
    MSG_PROMPT_CLIENT_SECRET,
    MSG_PROMPT_CONFIG_ENTITLEMENTS_URL,
    MSG_PROMPT_CRS_CATALOG_URL,
    MSG_PROMPT_CRS_CONVERTER_URL,
    MSG_PROMPT_DATA_PARTITION,
    MSG_PROMPT_FILE_URL,
    MSG_PROMPT_LEGAL_TAG,
    MSG_PROMPT_LEGAL_URL,
    MSG_PROMPT_MANAGE_GLOBAL,
    MSG_PROMPT_REFRESH_TOKEN,
    MSG_PROMPT_SCHEMA_URL,
    MSG_PROMPT_SCOPES,
    MSG_PROMPT_SEARCH_URL,
    MSG_PROMPT_SERVER,
    MSG_PROMPT_STORAGE_URL,
    MSG_PROMPT_TOKEN_ENDPOINT_URL,
    MSG_PROMPT_UNIT_URL,
    MSG_PROMPT_WELLBORE_DDMS_URL,
    MSG_PROMPT_WORKFLOW_URL,
)
from osducli.commands.config.info import print_cur_configuration
from osducli.config import (
    CONFIG_ACL_OWNER,
    CONFIG_ACL_VIEWER,
    CONFIG_AUTHENTICATION_AUTHORITY,
    CONFIG_AUTHENTICATION_MODE,
    CONFIG_AUTHENTICATION_SCOPES,
    CONFIG_CLIENT_ID,
    CONFIG_CLIENT_SECRET,
    CONFIG_CRS_CATALOG_URL,
    CONFIG_CRS_CONVERTER_URL,
    CONFIG_DATA_PARTITION_ID,
    CONFIG_ENTITLEMENTS_URL,
    CONFIG_FILE_URL,
    CONFIG_LEGAL_TAG,
    CONFIG_LEGAL_URL,
    CONFIG_REFRESH_TOKEN,
    CONFIG_SCHEMA_URL,
    CONFIG_SEARCH_URL,
    CONFIG_SERVER,
    CONFIG_STORAGE_URL,
    CONFIG_TOKEN_ENDPOINT,
    CONFIG_UNIT_URL,
    CONFIG_WELLBORE_DDMS_URL,
    CONFIG_WORKFLOW_URL,
    CLIConfig,
    get_default_choice_index_from_config,
    get_default_from_config,
)
from osducli.util.prompt import prompt, prompt_choice_list, prompt_y_n


@click.command(cls=CustomClickCommand)
@click.option("-k", "--key", help="A specific key to update.")
@click.option("-v", "--value", help="Value to update key with.")
@global_params
@handle_cli_exceptions
def _click_command(state: State, key: str = None, value: str = None):
    # def _click_command(ctx, debug, config, hostname):
    """Update configuration values. This command is interactive."""
    config_update(state, key, value)


def config_update(state: State, key: str, value: str):
    """Update configuration values.

    Args:
        state (State): Global state
        key (str): Key to update
        value (str): Value to update key with
    """
    if key is None:
        print(MSG_INTRO)
        _handle_configuration(state.config)
        print(MSG_CLOSING)
    else:
        print(f"Updating '{key}' only")
        if value is None:
            value = prompt("Enter the new value: ")
        if value != "":
            state.config.set_value("core", key, value)
        print("Done")


def _prompt_default_from_config(
        msg: str,
        config: configparser.ConfigParser,
        option: str,
        default_value_display_length: int = None,
        fallback: str = None,
):
    if config.has_option("core", option):
        default = get_default_from_config(config, "core", option)
    else:
        default = fallback

    return prompt(msg, default, default_value_display_length=default_value_display_length)


def _handle_configuration(config: CLIConfig):
    # print location of global configuration
    print(MSG_GLOBAL_SETTINGS_LOCATION.format(config.config_path))
    # set up the config parsers
    file_config = configparser.ConfigParser()
    config_exists = file_config.read([config.config_path])
    should_modify_global_config = False
    if config_exists:
        # print current config and prompt to allow global config modification
        print_cur_configuration(config)
        should_modify_global_config = prompt_y_n(MSG_PROMPT_MANAGE_GLOBAL, default="n")
    if not config_exists or should_modify_global_config:
        _configure_connection(config)

        _configure_authentication(config)


def _configure_authentication(config):
    # Setup authentication
    authentication_index = prompt_choice_list(
        MSG_PROMPT_AUTHENTICATION_MODE,
        AUTHENTICATION_LIST,
        default=get_default_choice_index_from_config(
            config, "core", CONFIG_AUTHENTICATION_MODE, AUTHENTICATION_LIST, fallback=1
        ),
    )

    config.set_value(
        "core", CONFIG_AUTHENTICATION_MODE, AUTHENTICATION_LIST[authentication_index]["name"]
    )

    # refresh_token
    if authentication_index == 0:
        token_endpoint = _prompt_default_from_config(
            MSG_PROMPT_TOKEN_ENDPOINT_URL, config, CONFIG_TOKEN_ENDPOINT, 40
        )
        refresh_token = _prompt_default_from_config(
            MSG_PROMPT_REFRESH_TOKEN, config, CONFIG_REFRESH_TOKEN, 40
        )
        client_id = _prompt_default_from_config(MSG_PROMPT_CLIENT_ID, config, CONFIG_CLIENT_ID, 40)
        client_secret = _prompt_default_from_config(
            MSG_PROMPT_CLIENT_SECRET, config, CONFIG_CLIENT_SECRET, 40
        )

        if token_endpoint != "":
            config.set_value("core", CONFIG_TOKEN_ENDPOINT, token_endpoint)
        if refresh_token != "":
            config.set_value("core", CONFIG_REFRESH_TOKEN, refresh_token)
        if client_id != "":
            config.set_value("core", CONFIG_CLIENT_ID, client_id)
        if client_secret != "":
            config.set_value("core", CONFIG_CLIENT_SECRET, client_secret)

    # msal interactive
    elif authentication_index == 1:
        authority = _prompt_default_from_config(
            MSG_PROMPT_AUTHORITY, config, CONFIG_AUTHENTICATION_AUTHORITY, 40
        )
        scopes = _prompt_default_from_config(
            MSG_PROMPT_SCOPES, config, CONFIG_AUTHENTICATION_SCOPES, 40
        )
        client_id = _prompt_default_from_config(MSG_PROMPT_CLIENT_ID, config, CONFIG_CLIENT_ID, 40)

        if authority != "":
            config.set_value("core", CONFIG_AUTHENTICATION_AUTHORITY, authority)
        if scopes != "":
            config.set_value("core", CONFIG_AUTHENTICATION_SCOPES, scopes)
        if client_id != "":
            config.set_value("core", CONFIG_CLIENT_ID, client_id)

    # msal non-interactive
    else:  # authentication_index == 2:
        authority = _prompt_default_from_config(
            MSG_PROMPT_AUTHORITY, config, CONFIG_AUTHENTICATION_AUTHORITY, 40
        )
        scopes = _prompt_default_from_config(
            MSG_PROMPT_SCOPES, config, CONFIG_AUTHENTICATION_SCOPES, 40
        )
        client_id = _prompt_default_from_config(MSG_PROMPT_CLIENT_ID, config, CONFIG_CLIENT_ID, 40)

        client_secret = _prompt_default_from_config(
            MSG_PROMPT_CLIENT_SECRET, config, CONFIG_CLIENT_SECRET, 40
        )

        if authority != "":
            config.set_value("core", CONFIG_AUTHENTICATION_AUTHORITY, authority)
        if scopes != "":
            config.set_value("core", CONFIG_AUTHENTICATION_SCOPES, scopes)
        if client_id != "":
            config.set_value("core", CONFIG_CLIENT_ID, client_id)
        if client_secret != "":
            config.set_value("core", CONFIG_CLIENT_SECRET, client_secret)


def _configure_connection(config):  # noqa C901
    server = _prompt_default_from_config(MSG_PROMPT_SERVER, config, CONFIG_SERVER)

    crs_catalog_url = _prompt_default_from_config(
        MSG_PROMPT_CRS_CATALOG_URL,
        config,
        CONFIG_CRS_CATALOG_URL,
        fallback="/api/crs/catalog/v2/",
    )

    crs_converter_url = _prompt_default_from_config(
        MSG_PROMPT_CRS_CONVERTER_URL,
        config,
        CONFIG_CRS_CONVERTER_URL,
        fallback="/api/crs/converter/v2/",
    )
    entitlements_url = _prompt_default_from_config(
        MSG_PROMPT_CONFIG_ENTITLEMENTS_URL,
        config,
        CONFIG_ENTITLEMENTS_URL,
        fallback="/api/entitlements/v2/",
    )
    file_url = _prompt_default_from_config(
        MSG_PROMPT_FILE_URL, config, CONFIG_FILE_URL, fallback="/api/file/v2/"
    )
    schema_url = _prompt_default_from_config(
        MSG_PROMPT_SCHEMA_URL, config, CONFIG_SCHEMA_URL, fallback="/api/schema-service/v1/"
    )
    legal_url = _prompt_default_from_config(
        MSG_PROMPT_LEGAL_URL, config, CONFIG_LEGAL_URL, fallback="/api/legal/v1/"
    )
    search_url = _prompt_default_from_config(
        MSG_PROMPT_SEARCH_URL, config, CONFIG_SEARCH_URL, fallback="/api/search/v2/"
    )
    storage_url = _prompt_default_from_config(
        MSG_PROMPT_STORAGE_URL, config, CONFIG_STORAGE_URL, fallback="/api/storage/v2/"
    )
    unit_url = _prompt_default_from_config(
        MSG_PROMPT_UNIT_URL, config, CONFIG_UNIT_URL, fallback="/api/unit/v3/"
    )
    wellbore_ddms_url = _prompt_default_from_config(
        MSG_PROMPT_WELLBORE_DDMS_URL, config, CONFIG_WELLBORE_DDMS_URL, fallback="/api/os-wellbore-ddms"
    )
    workflow_url = _prompt_default_from_config(
        MSG_PROMPT_WORKFLOW_URL, config, CONFIG_WORKFLOW_URL, fallback="/api/workflow/v1/"
    )

    data_partition_id = _prompt_default_from_config(
        MSG_PROMPT_DATA_PARTITION, config, CONFIG_DATA_PARTITION_ID, fallback="opendes"
    )
    legal_tag = _prompt_default_from_config(
        MSG_PROMPT_LEGAL_TAG,
        config,
        CONFIG_LEGAL_TAG,
        fallback="opendes-public-usa-dataset-7643990",
    )
    acl_viewer = _prompt_default_from_config(
        MSG_PROMPT_ACL_VIEWER,
        config,
        CONFIG_ACL_VIEWER,
        fallback="data.default.viewers@opendes.contoso.com",
    )
    acl_owner = _prompt_default_from_config(
        MSG_PROMPT_ACL_OWNER,
        config,
        CONFIG_ACL_OWNER,
        fallback="data.default.owners@opendes.contoso.com",
    )

    # save the global config
    if server != "":
        config.set_value("core", CONFIG_SERVER, server)
    if crs_catalog_url != "":
        config.set_value("core", CONFIG_CRS_CATALOG_URL, crs_catalog_url)
    if crs_converter_url != "":
        config.set_value("core", CONFIG_CRS_CONVERTER_URL, crs_converter_url)
    if entitlements_url != "":
        config.set_value("core", CONFIG_ENTITLEMENTS_URL, entitlements_url)
    if file_url != "":
        config.set_value("core", CONFIG_FILE_URL, file_url)
    if legal_url != "":
        config.set_value("core", CONFIG_LEGAL_URL, legal_url)
    if schema_url != "":
        config.set_value("core", CONFIG_SCHEMA_URL, schema_url)
    if search_url != "":
        config.set_value("core", CONFIG_SEARCH_URL, search_url)
    if storage_url != "":
        config.set_value("core", CONFIG_STORAGE_URL, storage_url)
    if unit_url != "":
        config.set_value("core", CONFIG_UNIT_URL, unit_url)
    if wellbore_ddms_url != "":
        config.set_value("core", CONFIG_WELLBORE_DDMS_URL, wellbore_ddms_url)
    if workflow_url != "":
        config.set_value("core", CONFIG_WORKFLOW_URL, workflow_url)

    if data_partition_id != "":
        config.set_value("core", CONFIG_DATA_PARTITION_ID, data_partition_id)
    if legal_tag != "":
        config.set_value("core", CONFIG_LEGAL_TAG, legal_tag)
    if acl_viewer != "":
        config.set_value("core", CONFIG_ACL_VIEWER, acl_viewer)
    if acl_owner != "":
        config.set_value("core", CONFIG_ACL_OWNER, acl_owner)
</file>

<file path="osducli/commands/crs/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Coordinate Reference System (CRS) service commands"""
</file>

<file path="osducli/commands/crs/_const.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""CRS constants"""

CRS_CATALOG_DOCUMENTATION = "https://community.opengroup.org/osdu/documentation/-/wikis/OSDU-(C)/Design-and-Implementation/OpenDES-API-Specifications/Documentation/core-services/CRSCatalogService"
CRS_CATALOG_SERVICE_NAME = "CRS Catalog service"
CRS_CATALOG_STATUS_PATH = "../_ah/readiness_check"
CRS_CATALOG_SWAGGER_PATH = "../swagger-ui.html"

CRS_CONVERTER_SERVICE_NAME = "CRS Converter service"
CRS_CONVERTER_STATUS_PATH = "../_ah/readiness_check"
CRS_CONVERTER_SWAGGER_PATH = "../swagger-ui.html"
</file>

<file path="osducli/commands/crs/areas.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""CRS Catalog areas command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_CRS_CATALOG_URL


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output("areasOfUse[].{Name:name}")
def _click_command(state: State):
    """List areas"""
    return area_list(state)


def area_list(state: State):
    """List areas

    Args:
        state (State): Global state
    """
    connection = CliOsduClient(state.config)
    json = connection.cli_get_returning_json(CONFIG_CRS_CATALOG_URL, "area?limit=10000")
    return json
</file>

<file path="osducli/commands/crs/info.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""CRS Catalog info command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import handle_cli_exceptions
from osducli.commands.crs._const import (
    CRS_CATALOG_DOCUMENTATION,
    CRS_CATALOG_SERVICE_NAME,
    CRS_CATALOG_STATUS_PATH,
    CRS_CATALOG_SWAGGER_PATH,
)
from osducli.config import CONFIG_CRS_CATALOG_URL
from osducli.util.service_info import info


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State) -> dict:
    """Information about the service"""
    return info(
        state,
        CRS_CATALOG_SERVICE_NAME,
        CONFIG_CRS_CATALOG_URL,
        CRS_CATALOG_STATUS_PATH,
        CRS_CATALOG_SWAGGER_PATH,
        CRS_CATALOG_DOCUMENTATION,
    )
</file>

<file path="osducli/commands/crs/list.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""CRS Catalog list command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_CRS_CATALOG_URL


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output(
    "crses[].{Name:aliasNames[0],Authority:baseCRSAuthorityCode.auth,Code:baseCRSAuthorityCode.code,Type:crstype,Source:source}"  # noqa: E501
)
def _click_command(state: State):
    """List coordinate referense systems"""
    return crs_list(state)


def crs_list(state: State):
    """List coordinate referense systems

    Args:
        state (State): Global state
    """
    connection = CliOsduClient(state.config)
    json = connection.cli_get_returning_json(CONFIG_CRS_CATALOG_URL, "crs?limit=10000")
    return json
</file>

<file path="osducli/commands/crs/summary.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""CRS Catalog summary command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_CRS_CATALOG_URL


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output("attributes.{Name:name,Description:description,LastModified:lastModified}")
def _click_command(state: State):
    """CRS catalog Summary"""
    return crs_summary(state)


def crs_summary(state: State):
    """CRS Summary

    Args:
        state (State): Global state
    """
    connection = CliOsduClient(state.config)
    json = connection.cli_get_returning_json(CONFIG_CRS_CATALOG_URL, "catalog")
    return json
</file>

<file path="osducli/commands/crs/transforms.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""CRS Catalog transforms command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_CRS_CATALOG_URL


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output(
    "cts[].{Name:aliasNames[0],FromAuthority:fromCRSAuthorityCode.auth,FromCode:fromCRSAuthorityCode.code,ToAuthority:toCRSAuthorityCode.auth,ToCode:toCRSAuthorityCode.code,Source:source}"  # noqa: E501
)
def _click_command(state: State):
    """List coordinate referense transforms"""
    return crs_transforms(state)


def crs_transforms(state: State):
    """List coordinate referense transforms

    Args:
        state (State): Global state
    """
    connection = CliOsduClient(state.config)
    json = connection.cli_get_returning_json(CONFIG_CRS_CATALOG_URL, "ct?limit=10000")
    return json
</file>

<file path="osducli/commands/dataload/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Data loading commands"""
</file>

<file path="osducli/commands/dataload/checkrefs.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Dataload missingreferences command"""

import dataclasses
import json
import os
import re as regex
import urllib

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import handle_cli_exceptions
from osducli.commands.dataload.verify import batch_verify
from osducli.config import (
    CONFIG_ACL_OWNER,
    CONFIG_ACL_VIEWER,
    CONFIG_LEGAL_TAG,
    CLIConfig,
)
from osducli.log import get_logger
from osducli.util.file import get_files_from_path

logger = get_logger(__name__)

DATA_SECTION = "Data"
DATASETS_SECTION = "Datasets"
MASTER_DATA_SECTION = "MasterData"
REFERENCE_DATA_SECTION = "ReferenceData"
WORK_PRODUCT_SECTION = "WorkProduct"
WORK_PRODUCT_COMPONENTS_SECTION = "WorkProductComponents"


# click entry point
@click.command(cls=CustomClickCommand)
@click.option(
    "-p",
    "--path",
    help="Path to a manifest file or files to check.",
    type=click.Path(exists=True, file_okay=True, dir_okay=True, readable=True, resolve_path=True),
    required=True,
)
@click.option(
    "-g",
    "--generated",
    help="Path where manifests for missing references should be created.",
    type=click.Path(exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True),
    required=False,
)
@click.option(
    "-a",
    "--authority",
    help="Schema authority to use when generating manifest files.",
    default="osdu",
    show_default=True,
    required=False,
)
@click.option(
    "-aclo",
    "--acl-owners",
    help=(
        "Acl owners to use when generating manifest files. If not specified the global value is"
        " used."
    ),
)
@click.option(
    "-aclv",
    "--acl-viewers",
    help=(
        "Acl viewers to use when generating manifest files. If not specified the global value is"
        " used."
    ),
)
@click.option(
    "-l",
    "--legal-tags",
    help=(
        "Legal tag to use when generating manifest files. If not specified the global value is"
        " used."
    ),
)
# @click.option("-b", "--batch", help="Batch size.", type=int, default=200, show_default=True)
# @click.option(
#     "--batch-across-files",
#     is_flag=True,
#     default=True,
#     help="Create batches across files for speed.",
#     show_default=True,
# )
@handle_cli_exceptions
@command_with_output(None)
def _click_command(
    state: State,
    path: str,
    generated: str,
    authority: str,
    acl_owners: str,
    acl_viewers: str,
    legal_tags: str,
):
    """Find any referenced id's missing in OSDU (work in progress).

    This command will try and extract all referenced id's in the given manifests and then check
    whether these exist in OSDU. You might typically use this command prior to ingestion to check
    whether ingestion might fail due to the referential integrity check."""
    return check_references(
        state,
        path,
        generated,
        authority,
        acl_owners,
        acl_viewers,
        legal_tags,
    )


# region Create Manifests
def create_reference_data_manifest_json(
    data_partition: str,
    kind: str,
    code: str,
    authority: str,
    acl_owners: str,
    acl_viewers: str,
    legal_tags: str,
):
    """
    Create a manifest json representation

    """
    data = {
        "kind": f"{data_partition}:wks:Manifest:1.0.0",
        "ReferenceData": [
            {
                "id": f"{data_partition}:{kind}:{code}",
                "kind": f"{authority}:wks:{kind}:1.0.0",
                "acl": {
                    "owners": [acl_owners],
                    "viewers": [acl_viewers],
                },
                "legal": {
                    "legaltags": [legal_tags],
                    "otherRelevantDataCountries": ["US"],
                },
                "data": {
                    "Name": f"{code}",
                    "Description": "",
                    "ID": f"{code}",
                    "Code": f"{code}",
                    "InactiveIndicator": False,
                    "AttributionAuthority": "Equinor",
                    "AttributionPublication": "Equinor Automatic Reference Data Dictionary V1.0",
                    "AttributionRevision": "1.0",
                    "Source": "Automatically generated by OSDU CLI",
                },
            }
        ],
    }

    # Add schema specific fields
    if kind == "reference-data--UnitOfMeasure":
        data["ReferenceData"][0]["data"].update(
            {
                "BaseForConversion": "e.g. cd/m2",
                "MemberUnits": ["e.g. cd/m2"],
                "ParentUnitQuantity": "e.g. J/L2",
                "PersistableReference": '{"ancestry":"e.g. J/L2.luminance","type":"e.g. UM"}',
                "UnitDimension": "e.g. J/L2",
            }
        )

    return data


def create_master_data_manifest_json(
    data_partition: str,
    kind: str,
    code: str,
    authority: str,
    acl_owners: str,
    acl_viewers: str,
    legal_tags: str,
):
    """
    Create a manifest json representation

    """
    data = {
        "kind": f"{data_partition}:wks:Manifest:1.0.0",
        "MasterData": [
            {
                "id": f"{data_partition}:{kind}:{code}",
                "kind": f"{authority}:wks:{kind}:1.0.0",
                "acl": {
                    "owners": [acl_owners],
                    "viewers": [acl_viewers],
                },
                "legal": {
                    "legaltags": [legal_tags],
                    "otherRelevantDataCountries": ["US"],
                },
                "data": {},
            }
        ],
    }

    # Add schema specific fields
    if kind == "master-data--Organisation":
        data["MasterData"][0]["data"].update({"OrganisationName": f"{urllib.parse.unquote(code)}"})
    elif kind == "master-data--GeoPoliticalEntity":
        data["MasterData"][0]["data"].update(
            {"GeoPoliticalEntityName": f"{urllib.parse.unquote(code)}"}
        )
    elif kind == "master-data--Field":
        data["MasterData"][0]["data"].update({"FieldName": f"{urllib.parse.unquote(code)}"})
    elif kind == "master-data--Seismic3DInterpretationSet":
        data["MasterData"][0]["data"].update({"ProjectName": f"{urllib.parse.unquote(code)}"})
    else:
        logger.warning(
            "%s not handled and will likely fail upload with empty data element exception.", kind
        )

    return data


def write_manifest(kind, name, output_dir, manifest):
    """Write the specified manifest to disk

    Args:
        kind ([type]): [description]
        name ([type]): [description]
        output_dir ([type]): [description]
        manifest ([type]): [description]
    """
    folder = os.path.join(output_dir, kind)
    if not os.path.exists(folder):
        os.makedirs(folder)
    with open(os.path.join(folder, f"{name}.json"), "w", encoding="utf-8") as outfile:
        json.dump(manifest, outfile, indent=2)


def create_reference_data_manifest(
    data_partition: str,
    kind: str,
    name: str,
    authority: str,
    acl_owners: str,
    acl_viewers: str,
    legal_tags: str,
    output_dir: str,
    # , batch_size: int, batch_across_files: bool
):
    """Create a reference data manifest file

    Args:
        data_partition (str): [description]
        kind (str): [description]
        name (str): [description]
        authority (str): [description],
        acl_owners (str): [description],
        acl_viewers (str): [description],
        legal_tags (str): [description],
        output_dir (str): [description]
    """
    manifest = create_reference_data_manifest_json(
        data_partition, kind, name, authority, acl_owners, acl_viewers, legal_tags
    )
    write_manifest(kind, name, output_dir, manifest)


def create_master_data_manifest(
    data_partition: str,
    kind: str,
    name: str,
    authority: str,
    acl_owners: str,
    acl_viewers: str,
    legal_tags: str,
    output_dir: str,
):
    """Create a master data manifest file

    Args:
        data_partition (str): [description]
        kind (str): [description]
        name (str): [description]
        authority (str): [description],
        acl_owners (str): [description],
        acl_viewers (str): [description],
        legal_tags (str): [description],
        output_dir (str): [description]
    """
    manifest = create_master_data_manifest_json(
        data_partition, kind, name, authority, acl_owners, acl_viewers, legal_tags
    )
    write_manifest(kind, name, output_dir, manifest)


# endregion Create Manifests


@dataclasses.dataclass
class EntityId:
    """Data class to hold id and version"""

    id: str  # pylint: disable=invalid-name
    version: str = ""

    @property
    def srn(self):
        """Get string representation"""
        return f"{self.id}:{self.version}"


def split_id(id_value: str) -> EntityId:
    """
    Get id without a version for searching later.

    :id_value: ID of some entity with or without versions.
    """
    version = ""
    if id_value.endswith(":"):
        _id = id_value[:-1]
    elif id_value.split(":")[-1].isdigit():
        version = str(id_value.split(":")[-1])
        _id = id_value[: -len(version) - 1]
    else:
        _id = id_value

    return EntityId(_id, version)


class ValidationIntegrityError(Exception):
    """Raise when an entity does not pass validation integrity."""


class EmptyManifestError(Exception):
    """Raise when manifest field is empty."""


class ManifestIntegrity:
    """Class to validate if parents reference and master data are exists and
    remove non-valid entities to provide integrity
    """

    REFERENCE_DATA_ID_PATTERN = regex.compile(
        r"(?<=\")[\w\-\.]+:reference-data\-\-[\w\-\.]+:.[^,;\"]+(?=\")", regex.I + regex.M
    )
    MASTER_DATA_ID_PATTERN = regex.compile(
        r"(?<=\")[\w\-\.]+:master-data\-\-[\w\-\.]+:.[^,;\"]+(?=\")", regex.I + regex.M
    )
    WORK_PRODUCT_ID_PATTERN = regex.compile(
        r"(?<=\")[\w\-\.]+:work-product\-\-[\w\-\.]+:.[^,;\"]+(?=\")", regex.I + regex.M
    )
    WORK_PRODUCT_COMPONENT_ID_PATTERN = regex.compile(
        r"(?<=\")[\w\-\.]+:work-product-component\-\-[\w\-\.]+:.[^,;\"]+(?=\")", regex.I + regex.M
    )
    DATASET_ID_PATTERN = regex.compile(
        r"(?<=\")[\w\-\.]+:dataset\-\-[\w\-\.]+:.[^,;\"]+(?=\")", regex.I + regex.M
    )
    SURROGATE_KEY_PATTERN = regex.compile(r"(?<=\")surrogate-key:[\w\-\.\d]+(?=\")", regex.I + regex.M)

    def __init__(
        self,
        config: CLIConfig,
        # search_url: str,
        # request_headers: str,
        # context: Context,
    ):
        self.config = config
        # self.search_url = search_url
        # self.request_headers = request_headers
        # self.context = context
        self.ids_for_validation = []
        self.entities_ids = set()
        self.rejected_entities_ids = set()
        self.ref_patterns = [
            self.REFERENCE_DATA_ID_PATTERN,
            self.MASTER_DATA_ID_PATTERN,
            self.WORK_PRODUCT_ID_PATTERN,
            self.WORK_PRODUCT_COMPONENT_ID_PATTERN,
            self.DATASET_ID_PATTERN,
            self.SURROGATE_KEY_PATTERN,
        ]

        super().__init__()

    @staticmethod
    def _match_id_with_pattern(pattern: regex.Pattern, source: str) -> list[str]:
        return pattern.findall(source)

    @staticmethod
    def _collect_ids_by_data_types(manifest_section: dict, data_type: str):
        """
        Collect manifest entities ids by their data types.

        :param manifest_section: A part of the manifest, where data types can be accessed.
        :param data_type: ReferenceData, MasterData etc.
        """
        entities_ids = []
        if manifest_section.get(data_type):
            for elem in manifest_section[data_type]:
                if elem.get("id"):
                    entities_ids.append(elem["id"])
        return entities_ids

    def collect_manifest_entities_ids(self, manifest: dict):
        """
        Collect manifest's entities ids to exclude them while checking integrity.

        :manifest: Manifest.
        """
        entities_ids = []
        for data_type in (REFERENCE_DATA_SECTION, MASTER_DATA_SECTION):
            entities_ids.extend(self._collect_ids_by_data_types(manifest, data_type))

        if manifest.get(DATA_SECTION):
            if manifest[DATA_SECTION].get(WORK_PRODUCT_SECTION, {}).get("id"):
                entities_ids.append(manifest[DATA_SECTION][WORK_PRODUCT_SECTION]["id"])

            for data_type in (WORK_PRODUCT_COMPONENTS_SECTION, DATASETS_SECTION):
                entities_ids.extend(
                    self._collect_ids_by_data_types(manifest[DATA_SECTION], data_type)
                )

        self.entities_ids = set(entities_ids)

    def extract_references(self, entity: dict) -> set:
        """
        Extract references (everything looking like an ID to another entity) from the entity.

        :param entity: Manifest's entity
        :return: Set of ids to other entities or records.
        """
        manifest_str = json.dumps(entity)
        references = set()
        for pattern in self.ref_patterns:
            references.update(set(self._match_id_with_pattern(pattern, manifest_str)))
        references.discard(entity.get("id"))
        return references

    def extract_external_references(self, entity: dict, entity_references: set) -> list[EntityId]:
        """

        Extract external reference ids from an entity. These references are supposed
        to be searchable via Search service.

        :param entity: Manifest's entity.
        :param entity_references: All entity's references.
        :return: Set of external references.
        """
        entity_references = [split_id(ref) for ref in entity_references]
        external_references = [e for e in entity_references if e.id not in self.entities_ids]
        logger.debug(
            "Entity id: %s, kind %s. External reference ids: %s",
            entity.get("id"),
            entity.get("kind"),
            external_references,
        )

        return external_references

    def find_missing_external_ids(self, external_references: list[EntityId]) -> set[str]:
        """
        Find absent external references in the system and searchable

        :param external_references: Records IDs are supposed to be found in Search.
        :return: Set of not found references via Search.
        """
        missing_ids = set()
        external_references_without_version = [e.id for e in external_references]

        # Search can't work with ids with versions. So get only ids without versions.
        # TO DO: Move ExtendedSearchId() to the class attribute.
        #  Refactor ExtendedSearchId().search_records() to take records to search
        # search_handler = ExtendedSearchId(
        #     self.search_url, external_references_without_version, self.request_headers, self.context
        # )
        # found_ids = search_handler.search_records()
        batch_size = 200
        found = []
        not_found = []
        batch_verify(
            self.config,
            batch_size,
            external_references_without_version,
            found,
            not_found,
            True,
        )

        for entity_id in external_references:
            # As found_ids contains ids with versions and bare ids, and if entity_id is an id
            # with no version (refers to the last version), we use just the bare id.
            entity_srn = entity_id.srn if entity_id.version else entity_id.id
            if entity_srn not in found:
                missing_ids.add(entity_id.srn)

        return missing_ids

    def _validate_referential_integrity(self, entity: dict):
        """
        Check if a manifest's entity passes referential integrity.

        :param entity: Manifest's entity.
        """
        missing_ids = set()
        references = self.extract_references(entity)
        external_references = self.extract_external_references(entity, references)
        if external_references:
            missing_external_ids = self.find_missing_external_ids(external_references)
            if missing_external_ids:
                missing_ids.update(missing_external_ids)

        if missing_ids:
            logger.warning(
                "Resource with kind %s and id: '%s' was rejected. Missing ids '%s'",
                entity.get("kind"),
                entity.get("id"),
                missing_ids,
            )
            raise ValidationIntegrityError(entity, reason=f"Missing referential id: {missing_ids}")

    def _ensure_manifest_entity_integrity(
        self, manifest_section: list[dict]
    ) -> tuple[list[dict], list[dict]]:
        """
        Ensure integrity of entities in given manifest parts. If records don't pass this validation
        they are deleted from the manifest.

        Args:
            manifest_section: A part of the manifest, where data types can be accessed.
        Returns:
            List of valid entities and list of invalid entities.
        """
        valid_entities = []
        skipped_entities = []
        for entity in manifest_section:
            try:
                self._validate_referential_integrity(entity)
            except ValidationIntegrityError:  # as error:
                # skipped_entities.append(error.skipped_entity)
                pass
            else:
                valid_entities.append(entity)
        return valid_entities, skipped_entities

    def _ensure_work_product_entity_integrity(self, work_product: dict) -> tuple[dict, list[dict]]:
        """
        Ensure integrity of entities in given manifest parts. If records don't pass this validation
        they are deleted from the manifest.

        :param work_product: A part of the manifest, where data types can be accessed.
        :return: The work product if it is valid, otherwise, empty dict.
        """
        try:
            self._validate_referential_integrity(work_product)
            return work_product, []
        except ValidationIntegrityError:  # as error:
            return {}, []  # error.skipped_entity]

    @staticmethod
    def _ensure_wpc_artefacts_integrity(wpc: dict):
        artefacts = wpc["data"].get("Artefacts")
        if not artefacts:
            logger.debug("WPC: %s doesn't have Artefacts field. Mark it as valid.", wpc.get("id"))
            return
        artefacts_resource_ids = set(artefact["ResourceID"] for artefact in artefacts)
        datasets = set(wpc["data"].get(DATASETS_SECTION, []))
        duplicated_ids = artefacts_resource_ids.intersection(datasets)
        if duplicated_ids:
            logger.warning(
                "Resource kind '%s' and id '%s' was rejected. "
                "The WPC's Artefacts field contains the same ids as in "
                "the WPC's 'Datasets': %s.",
                wpc.get("kind"),
                wpc.get("id", ""),
                duplicated_ids,
            )
            raise ValidationIntegrityError(
                wpc, reason=f"It has duplicated Datasets and Artefacts: {duplicated_ids}."
            )

    def _ensure_artefacts_integrity(
        self, work_product_components: list
    ) -> tuple[list[dict], list[dict]]:
        """
        Delete a WPC entity if it didn't passed artefacts integrity check.

        Args:
            work_product_components:
        Returns:
            List of valid wpcs.
        """
        valid_work_product_components = []
        skipped_ids = []
        for wpc in work_product_components:
            try:
                self._ensure_wpc_artefacts_integrity(wpc)
            except ValidationIntegrityError:  # as error:
                pass
                # skipped_ids.append(error.skipped_entity)
            else:
                valid_work_product_components.append(wpc)
        return valid_work_product_components, skipped_ids

    def ensure_integrity(self, manifest: dict = None) -> tuple[dict, list[dict]]:
        """
        Validate reference ids in traversal manifest file

        :return: only valid entities in the same structure
        """
        skipped_entities = []

        if not manifest:
            raise EmptyManifestError()

        self.collect_manifest_entities_ids(manifest)

        for data_type in (REFERENCE_DATA_SECTION, MASTER_DATA_SECTION):
            if manifest.get(data_type):
                valid_entities, not_valid_entities = self._ensure_manifest_entity_integrity(
                    manifest[data_type]
                )
                manifest[data_type] = valid_entities
                skipped_entities.extend(not_valid_entities)

        if manifest.get(DATA_SECTION):
            if manifest[DATA_SECTION].get(DATASETS_SECTION):
                datasets = manifest[DATA_SECTION].get(DATASETS_SECTION)
                valid_entities, not_valid_entities = self._ensure_manifest_entity_integrity(
                    datasets
                )
                manifest[DATA_SECTION][DATASETS_SECTION] = valid_entities
                skipped_entities.extend(not_valid_entities)

            if manifest[DATA_SECTION].get(WORK_PRODUCT_COMPONENTS_SECTION):
                work_product_components = manifest[DATA_SECTION][WORK_PRODUCT_COMPONENTS_SECTION]
                valid_entities, not_valid_entities = self._ensure_manifest_entity_integrity(
                    work_product_components
                )
                skipped_entities.extend(not_valid_entities)
                valid_entities, not_valid_entities = self._ensure_artefacts_integrity(
                    valid_entities
                )
                manifest[DATA_SECTION][WORK_PRODUCT_COMPONENTS_SECTION] = valid_entities
                skipped_entities.extend(not_valid_entities)

            if manifest[DATA_SECTION].get(WORK_PRODUCT_SECTION):
                work_product_data = manifest[DATA_SECTION][WORK_PRODUCT_SECTION]
                valid_entities, not_valid_entities = self._ensure_work_product_entity_integrity(
                    work_product_data
                )
                manifest[DATA_SECTION][WORK_PRODUCT_SECTION] = valid_entities
                skipped_entities.extend(not_valid_entities)

        return manifest, skipped_entities


def get_missing_ids(manifest_integrity: ManifestIntegrity, entity: dict) -> set():
    """
    Check if a manifest's entity passes referential integrity.

    Args:
        manifest_integrity (ManifestIntegrity): Manifest integrity instance.
        entity (dict): Manifest's entity.

    Returns:
        set: Missing ids.
    """
    missing_ids = set()
    references = manifest_integrity.extract_references(entity)
    external_references = manifest_integrity.extract_external_references(entity, references)
    if external_references:
        missing_external_ids = manifest_integrity.find_missing_external_ids(external_references)
        if missing_external_ids:
            missing_ids.update(missing_external_ids)
    return missing_ids

    # """
    # missing_ids = set()
    # references = manifest_integrity._extract_references(entity)
    # external_references = manifest_integrity._extract_external_references(entity, references)

    # # scan for new ids not in cache
    # external_references_to_check = [e for e in external_references if e.id not in cache_checked_ids]
    # if external_references_to_check:
    #     missing_external_ids = manifest_integrity._find_missing_external_ids(external_references_to_check)
    #     if missing_external_ids:
    #         missing_ids.update(missing_external_ids)
    #         cache_missing_ids.update(missing_external_ids)

    # # add missing ids already found from cache
    # missing_ids.update([e.id for e in external_references if e.id in cache_missing_ids])

    # cache_checked_ids.update([e.id for e in external_references])   # cache id's that we have checked.
    # return missing_ids


def get_manifest_entity_missing_ids(
    manifest_integrity: ManifestIntegrity, manifest_section: list[dict]
) -> tuple[list[dict], list[dict], list[str]]:
    """
    Ensure integrity of entities in given manifest parts. If records don't pass this validation
    they are deleted from the manifest.

    Args:
        manifest_integrity: Manifest integrity instance.
        manifest_section: A part of the manifest, where data types can be accessed.

    Returns:
        List of valid entities and list of invalid entities.
    """
    valid_entities = []
    invalid_entities = []
    missing_ids = set()
    for entity in manifest_section:
        temp_missing_ids = get_missing_ids(manifest_integrity, entity)
        if temp_missing_ids:
            invalid_entities.append(entity)
            missing_ids.update(temp_missing_ids)
        else:
            valid_entities.append(entity)
    return valid_entities, invalid_entities, missing_ids


def get_work_product_missing_ids(
    manifest_integrity: ManifestIntegrity, work_product: dict
) -> tuple[dict, list[dict], list[str]]:
    """
    Ensure integrity of entities in given manifest parts. If records don't pass this validation
    they are deleted from the manifest.

    Args:
        manifest_integrity: Manifest integrity instance.
        work_product: A part of the manifest, where data types can be accessed.
    Returns:
        The work product if it is valid, otherwise, empty dict.
    """
    missing_ids = get_missing_ids(manifest_integrity, work_product)
    if len(missing_ids) > 0:
        return work_product, [], missing_ids

    return {}, work_product, missing_ids


def create_wpc_artefacts_missing_ids(wpc: dict):
    """Add docstring"""
    artefacts = wpc["data"].get("Artefacts")
    if not artefacts:
        logger.debug("WPC: %s doesn't have Artefacts field. Mark it as valid.", wpc.get("id"))
        return
    artefacts_resource_ids = set(artefact["ResourceID"] for artefact in artefacts)
    datasets = set(wpc["data"].get(DATASETS_SECTION, []))
    duplicated_ids = artefacts_resource_ids.intersection(datasets)
    if duplicated_ids:
        logger.warning(
            "Resource kind '%s' and id '%s' was rejected. "
            "The WPC's Artefacts field contains the same ids as in "
            "the WPC's 'Datasets': %s.",
            wpc.get("kind"),
            wpc.get("id", ""),
            duplicated_ids,
        )
        raise ValidationIntegrityError(
            wpc, reason=f"It has duplicated Datasets and Artefacts: {duplicated_ids}."
        )


def get_artefacts_missing_ids(
    work_product_components: list,
) -> tuple[list[dict], list[dict], list[str]]:
    """
    Delete a WPC entity if it didn't passed artefacts integrity check.

    Args:
        work_product_components:
    Returns:
        List of valid wpcs.
    """
    valid_work_product_components = []
    skipped_ids = []
    for wpc in work_product_components:
        try:
            create_wpc_artefacts_missing_ids(wpc)
        except ValidationIntegrityError:
            skipped_ids.append(wpc)
        else:
            valid_work_product_components.append(wpc)
    return valid_work_product_components, skipped_ids, []


def get_missing_ids_from_manifest(
    config: CLIConfig, manifest: dict = None
) -> tuple[dict, list[dict], set[str]]:
    """
    Get missing reference ids in traversal manifest file

    :return: only valid entities in the same structure
    """
    if not manifest:
        raise EmptyManifestError()

    invalid_entities = []
    missing_ids = set()

    manifest_integrity = ManifestIntegrity(config)

    manifest_integrity.collect_manifest_entities_ids(manifest)

    for data_type in (REFERENCE_DATA_SECTION, MASTER_DATA_SECTION):
        if manifest.get(data_type):
            valid_entities, not_valid_entities, tmp_missing_ids = get_manifest_entity_missing_ids(
                manifest_integrity, manifest[data_type]
            )
            manifest[data_type] = valid_entities
            invalid_entities.extend(not_valid_entities)
            missing_ids.update(tmp_missing_ids)

    if manifest.get(DATA_SECTION):
        if manifest[DATA_SECTION].get(DATASETS_SECTION):
            datasets = manifest[DATA_SECTION].get(DATASETS_SECTION)
            valid_entities, not_valid_entities, tmp_missing_ids = get_manifest_entity_missing_ids(
                manifest_integrity, datasets
            )
            manifest[DATA_SECTION][DATASETS_SECTION] = valid_entities
            invalid_entities.extend(not_valid_entities)
            missing_ids.update(tmp_missing_ids)

        if manifest[DATA_SECTION].get(WORK_PRODUCT_COMPONENTS_SECTION):
            work_product_components = manifest[DATA_SECTION][WORK_PRODUCT_COMPONENTS_SECTION]
            valid_entities, not_valid_entities, tmp_missing_ids = get_manifest_entity_missing_ids(
                manifest_integrity, work_product_components
            )
            invalid_entities.extend(not_valid_entities)
            missing_ids.update(tmp_missing_ids)
            valid_entities, not_valid_entities, tmp_missing_ids = get_artefacts_missing_ids(
                valid_entities
            )
            manifest[DATA_SECTION][WORK_PRODUCT_COMPONENTS_SECTION] = valid_entities
            invalid_entities.extend(not_valid_entities)
            missing_ids.update(tmp_missing_ids)

        if manifest[DATA_SECTION].get(WORK_PRODUCT_SECTION):
            work_product_data = manifest[DATA_SECTION][WORK_PRODUCT_SECTION]
            valid_entities, not_valid_entities, tmp_missing_ids = get_work_product_missing_ids(
                manifest_integrity, work_product_data
            )
            manifest[DATA_SECTION][WORK_PRODUCT_SECTION] = valid_entities
            invalid_entities.extend(not_valid_entities)
            missing_ids.update(tmp_missing_ids)

    return manifest, invalid_entities, missing_ids


def check_references(  # noqa: C901
    state: State,
    path: str,
    manifest_output_dir: str = None,
    authority: str = "osdu",
    acl_owners: str = None,
    acl_viewers: str = None,
    legal_tags: str = None,  # , batch_size: int, batch_across_files: bool
) :
    """Find any referenced id's that are missing in OSDU.

    Args:
        state (State): Global state
        path (str): Path to a file containing run ids to get status of
        manifest_output_dir (str): [description]
        authority (str): [description]
        acl_owners (str): [description]
        acl_viewers (str): [description]
        legal_tags (str): [description]
    """
    if legal_tags is None:
        legal_tags = state.config.get("core", CONFIG_LEGAL_TAG)
    if acl_owners is None:
        acl_owners = state.config.get("core", CONFIG_ACL_OWNER)
    if acl_viewers is None:
        acl_viewers = state.config.get("core", CONFIG_ACL_VIEWER)

    files = get_files_from_path(path)
    logger.debug("Files list: %s", files)

    missing_ids = set()
    for filepath in files:
        if filepath.endswith(".json"):
            with open(filepath, encoding="utf-8") as file:
                data_object = json.load(file)

                logger.info("Processing file %s.", filepath)

                if not data_object:
                    logger.error("Error with file %s. File is empty.", filepath)

                _, _, tmp_missing_ids = get_missing_ids_from_manifest(state.config, data_object)
                logger.info("%i missing id's %s", len(tmp_missing_ids), tmp_missing_ids)
                missing_ids.update(tmp_missing_ids)

    # display missing ids
    if len(missing_ids) > 0:
        logger.info("Total %i missing id's found", len(missing_ids))
        for _id in missing_ids:
            # Create missing entries
            if not manifest_output_dir:
                logger.info("Missing %s", _id)
            else:
                logger.info("Creating %s", _id)
                parts = _id.split(":")
                assert len(parts) == 4
                data_partition = parts[0]
                kind = parts[1]
                code = parts[2]
                # version = parts[3]

                if kind.startswith("reference-data"):
                    create_reference_data_manifest(
                        data_partition,
                        kind,
                        code,
                        authority,
                        acl_owners,
                        acl_viewers,
                        legal_tags,
                        manifest_output_dir,
                    )
                elif kind.startswith("master-data"):
                    create_master_data_manifest(
                        data_partition,
                        kind,
                        code,
                        authority,
                        acl_owners,
                        acl_viewers,
                        legal_tags,
                        manifest_output_dir,
                    )
                else:
                    logger.warning("Unknown type %s. Not created!", _id)
        if manifest_output_dir:
            logger.info(
                "Manifest files created. You should manually edit these"
                " before uploading including any additional fields."
            )
            logger.info(
                "Check also that missing references aren't already included as part of the"
                " scanned data (this check is currently not implemented)!"
            )
    else:
        logger.info("No missing id's found")
</file>

<file path="osducli/commands/dataload/ingest.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Dataload ingest command"""

import json
import os
import re

import click
import requests

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.commands.dataload.verify import batch_verify
from osducli.commands.workflow.status import check_status
from osducli.config import (
    CONFIG_ACL_OWNER,
    CONFIG_ACL_VIEWER,
    CONFIG_DATA_PARTITION_ID,
    CONFIG_FILE_URL,
    CONFIG_LEGAL_TAG,
    CONFIG_WORKFLOW_URL,
    CLIConfig,
)
from osducli.log import get_logger
from osducli.util.exceptions import CliError
from osducli.util.file import get_files_from_path

logger = get_logger(__name__)
VERIFY_BATCH_SIZE = 200


# click entry point
@click.command(cls=CustomClickCommand)
@click.option(
    "-p",
    "--path",
    help="Path to a sequence file, manifest file or folder with manifest files to ingest.",
    type=click.Path(exists=True, file_okay=True, dir_okay=True, readable=True, resolve_path=True),
    required=True,
)
@click.option("-f", "--files", help="Associated files to upload for Work-Products.")
@click.option(
    "-b",
    "--batch",
    help="Batch size (per file). If not specified manifests are uploaded as is.",
    is_flag=False,
    flag_value=200,
    type=int,
    default=None,
    show_default=True,
)
@click.option(
    "-rl",
    "--runid-log",
    help="Path to a file to save run ids to to later check status of (see dataload status -h).",
)
@click.option(
    "-w", "--wait", help="Whether to wait for runs to complete.", is_flag=True, show_default=True
)
@click.option(
    "-s",
    "--skip-existing",
    help="Skip reloading records that already exist.",
    is_flag=True,
    default=False,
    show_default=True,
)
@click.option("--simulate", help="Simulate ingestion only.", is_flag=True, show_default=True)
# @click.option(
#     "-a",
#     "--authority",
#     help="Schema authority to use when generating manifest files.",
#     default="osdu",
#     show_default=True,
#     required=False,
# )
# @click.option(
#     "-d",
#     "--data-partition",
#     help="A data partition name to use when generating manifest files. If not specified the default value is used.",
# )
@click.option(
    "-l",
    "--legal-tags",
    help=(  # noqa: E501
        "Rewrite existing legal tags. Specify either a comma seperated list of values or without a"
        " value to use the default value from config."
    ),
    is_flag=False,
    flag_value="",
    default=None,
    show_default=True,
)
@click.option(
    "-aclo",
    "--acl-owners",
    help=(  # noqa: E501
        "Rewrite existing acl owners. Specify either a comma seperated list of values or without a"
        " value to use the default value from config."
    ),
    is_flag=False,
    flag_value="",
    default=None,
    show_default=True,
)
@click.option(
    "-aclv",
    "--acl-viewers",
    help=(  # noqa: E501
        "Rewrite existing acl viewers. Specify either a comma seperated list of values or without a"
        " value to use the default value from config."
    ),
    is_flag=False,
    flag_value="",
    default=None,
    show_default=True,
)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(
    state: State,
    path: str,
    files: str,
    batch: int,
    runid_log: str = None,
    wait: bool = False,
    skip_existing: str = False,
    simulate: bool = False,
    # authority: str = None,
    # data_partition: str = None,
    legal_tags: str = None,
    acl_owners: str = None,
    acl_viewers: str = None,
):  # pylint: disable=too-many-arguments
    """Ingest manifest files into OSDU.

    This command will take existing manfiest files and load them into OSDU via the workflow
    service and Airflow. 'legal' and 'acl' tags will be updated based upon the current
    configuration"""
    return ingest(
        state,
        path,
        files,
        batch,
        runid_log,
        wait,
        skip_existing,
        simulate,
        (
            # authority,
            # data_partition,
            None
            if legal_tags is None
            else [] if legal_tags == "" else legal_tags.split(",")
        ),
        None if acl_owners is None else [] if acl_owners == "" else acl_owners.split(","),
        None if acl_viewers is None else [] if acl_viewers == "" else acl_viewers.split(","),
    )


def ingest(  # pylint: disable=too-many-arguments
    state: State,
    path: str,
    files: str,
    batch_size: int = 1,
    runid_log: str = None,
    wait: bool = False,
    skip_existing: bool = False,
    simulate: bool = False,
    # authority: str = None,
    # data_partition: str = None,
    legal_tags: list[str] = None,
    acl_owners: list[str] = None,
    acl_viewers: list[str] = None,
) -> dict:
    """Ingest manifest files into OSDU

    Args:
        state (State): Global state
        path (str): [description]
        files (str): [description]
        batch_size (int): [description]
        runid_log (str): [description]
        wait (bool): [description]
        skip_existing (bool): [description]
        simulate (bool): [description]
        legal_tags (list[str]): [description]
        acl_owners (list[str]): [description]
        acl_viewers (list[str]): [description]

    Returns:
        dict: Response from service
    """
    manifest_files = get_files_from_path(path)
    logger.debug("Files list: %s", files)

    runids = _ingest_files(
        state.config,
        manifest_files,
        files,
        runid_log,
        batch_size,
        wait,
        skip_existing,
        simulate,
        legal_tags,
        acl_owners,
        acl_viewers,
    )
    print(runids)
    return runids


def _ingest_files(  # noqa:C901 pylint: disable=too-many-arguments
    config: CLIConfig,
    manifest_files,
    files,
    runid_log,
    batch_size,
    wait,
    skip_existing,
    simulate,
    legal_tags,
    acl_owners,
    acl_viewers,
):
    logger.debug("Files list: %s", manifest_files)
    runids = []
    runid_log_handle = None
    try:  # pylint: disable=too-many-try-statements
        if runid_log is not None and not simulate:
            # clear existing logs
            runid_log_handle = open(runid_log, "w", encoding="utf-8")  # pylint: disable=consider-using-with

        data_objects = []
        for filepath in manifest_files:
            if filepath.endswith(".json"):
                with open(filepath, encoding="utf-8") as file:
                    json_string = file.read()
                    # for reference data do replacements (acl, legal happens later)
                    json_string = json_string.replace(
                        "{{NAMESPACE}}", config.get("core", CONFIG_DATA_PARTITION_ID)
                    )
                    json_data = json.loads(json_string)

                    if not json_data:
                        logger.error("Error with file %s. File is empty.", filepath)
                    else:
                        logger.info("Processing %s.", filepath)

                        if isinstance(json_data, list):
                            _ingest_json_as_sequence_file(
                                config,
                                files,
                                runid_log,
                                batch_size,
                                skip_existing,
                                simulate,
                                runids,
                                json_data,
                                legal_tags,
                                acl_owners,
                                acl_viewers,
                            )

                        else:
                            # Note this code currently assumes only one of MasterData, ReferenceData or Data exists!
                            if "ReferenceData" in json_data and len(json_data["ReferenceData"]) > 0:  # noqa: E501 pylint: disable=else-if-used
                                _update_legal_and_acl_tags_all(
                                    config,
                                    json_data["ReferenceData"],
                                    legal_tags,
                                    acl_owners,
                                    acl_viewers,
                                )
                                if batch_size is None and not skip_existing:
                                    _create_and_submit(
                                        config, json_data, runids, runid_log_handle, simulate
                                    )
                                else:
                                    data_objects += json_data["ReferenceData"]
                                    file_batch_size = (
                                        len(data_objects)
                                        if skip_existing and not batch_size
                                        else batch_size
                                    )
                                    data_objects = _process_batch(
                                        config,
                                        file_batch_size,
                                        "ReferenceData",
                                        data_objects,
                                        runids,
                                        runid_log_handle,
                                        skip_existing,
                                        simulate,
                                    )
                            elif "MasterData" in json_data and len(json_data["MasterData"]) > 0:
                                _update_legal_and_acl_tags_all(
                                    config,
                                    json_data["MasterData"],
                                    legal_tags,
                                    acl_owners,
                                    acl_viewers,
                                )
                                if batch_size is None and not skip_existing:
                                    _create_and_submit(
                                        config, json_data, runids, runid_log_handle, simulate
                                    )
                                else:
                                    data_objects += json_data["MasterData"]
                                    file_batch_size = (
                                        len(data_objects)
                                        if skip_existing and not batch_size
                                        else batch_size
                                    )
                                    data_objects = _process_batch(
                                        config,
                                        file_batch_size,
                                        "MasterData",
                                        data_objects,
                                        runids,
                                        runid_log_handle,
                                        skip_existing,
                                        simulate,
                                    )
                            elif "Data" in json_data:
                                _update_work_products_metadata(
                                    config,
                                    json_data["Data"],
                                    files,
                                    simulate,
                                    legal_tags,
                                    acl_owners,
                                    acl_viewers,
                                )
                                _create_and_submit(
                                    config, json_data, runids, runid_log_handle, simulate
                                )
                            else:
                                logger.error(
                                    "No manifest ReferenceData, MasterData or Data section"
                                    " found in %s.",
                                    filepath,
                                )
            else:
                logger.warning("Skipping %s - no .json extension.", filepath)

    finally:
        if runid_log_handle is not None:
            runid_log_handle.close()

    if wait and not simulate:
        logger.debug("%d batches submitted. Waiting for run status", len(runids))
        check_status(config, runids, True)
    return runids


def _ingest_json_as_sequence_file(
    config,
    files,
    runid_log,
    batch_size,
    skip_existing,
    simulate,
    runids,
    sequence_file,
    legal_tags,
    acl_owners,
    acl_viewers,
):  # pylint: disable=too-many-arguments
    logger.info(
        "Processing as sequence file. Will wait for each entry to complete before submitting new."
    )

    if all(isinstance(entry, dict) and "FileName" in entry for entry in sequence_file):
        for entry in sequence_file:
            _sequence_run_ids = _ingest_files(
                config,
                get_files_from_path(entry["FileName"]),
                files,
                runid_log,
                batch_size,
                True,
                skip_existing,
                simulate,
                legal_tags,
                acl_owners,
                acl_viewers,
            )
            runids.extend(_sequence_run_ids)
    else:
        logger.error("Invalid sequence file.")


def _process_batch(
    config, batch_size, data_type, data_objects, runids, runid_log_handle, skip_existing, simulate
):
    if skip_existing:
        ids_to_verify = []
        found = []
        not_found = []
        original_length = len(data_objects)
        for data in data_objects:
            if "id" in data:
                ids_to_verify.append(data.get("id"))
        batch_verify(config, VERIFY_BATCH_SIZE, ids_to_verify, found, not_found, True)
        data_objects = [
            data for data in data_objects if "id" in data and data.get("id") in not_found
        ]
        logger.info(
            "%i of %i records already exist. Submitting %i records",
            len(found),
            original_length,
            len(data_objects),
        )

    while len(data_objects) > 0:
        total_size = len(data_objects)
        batch_size = min(batch_size, total_size)
        current_batch = data_objects[:batch_size]
        del data_objects[:batch_size]
        print(
            f"Processing batch - total {total_size}, batch size {len(current_batch)}, remaining"
            f" {len(data_objects)}"
        )

        manifest = {"kind": "osdu:wks:Manifest:1.0.0", data_type: current_batch}
        _create_and_submit(config, manifest, runids, runid_log_handle, simulate)

    return data_objects


def _create_and_submit(config, manifest, runids, runid_log_handle, simulate):
    request_data = _populate_request_body(config, manifest)
    if not simulate:
        connection = CliOsduClient(config)
        response_json = connection.cli_post_returning_json(
            CONFIG_WORKFLOW_URL, "workflow/Osdu_ingest/workflowRun", request_data
        )
        logger.debug("Response %s", response_json)

        runid = response_json.get("runId")
        logger.info("Returned runID: %s", runid)
        if runid_log_handle:
            runid_log_handle.write(f"{runid}\n")
        runids.append(runid)


def _populate_request_body(config: CLIConfig, manifest):
    request = {
        "executionContext": {
            "Payload": {
                "AppKey": "osdu-cli",
                "data-partition-id": config.get("core", CONFIG_DATA_PARTITION_ID),
            },
            "manifest": manifest,
        }
    }
    logger.debug("Request to be sent %s", json.dumps(request, indent=2))
    return request


def _upload_file(config: CLIConfig, filepath):
    connection = CliOsduClient(config)

    initiate_upload_response_json = connection.cli_get_returning_json(
        CONFIG_FILE_URL, "files/uploadURL"
    )
    location = initiate_upload_response_json.get("Location")

    if location:
        signed_url_for_upload = location.get("SignedURL")
        file_source = location.get("FileSource")

        headers = {"Content-Type": "application/octet-stream", "x-ms-blob-type": "BlockBlob"}
        with open(filepath, "rb") as file_handle:
            # pylint: disable=missing-timeout
            response = requests.put(signed_url_for_upload, data=file_handle, headers=headers)
            if response.status_code not in [200, 201]:
                raise CliError(f"({response.status_code}) {response.text[:250]}")

        # Need to figure how metadata is handled wrt. ariflow, fileid (returned v's manifest)
        # file_metadata = _populate_file_metadata_req_body(file_source)
        # _update_legal_and_acl_tags(config, file_metadata)
        # print(file_metadata)
        # update_metadata_response = connection.cli_post_returning_json(
        #     CONFIG_FILE_URL,
        #     "files/metadata",
        #     json.dumps(file_metadata),
        #     [200, 201],
        # )

        # generated_file_id = update_metadata_response.get("id")
        # logger.info(
        #     f"{filepath} is uploaded with file id {generated_file_id} with file source {file_source}"
        # )

        # # Get record version

        # file_record_version_response = connection.cli_get_returning_json(
        #     CONFIG_STORAGE_URL, "records/versions/" + generated_file_id
        # )
        # file_record_version = file_record_version_response.get("versions")[0]

        # metadata = {
        #     "file_id": generated_file_id,
        #     "file_source": file_source,
        #     "file_record_version": str(file_record_version),
        # }
        # print(metadata)

        # generated_file_id = upload_metadata_response_json.get("id")
        logger.info("%s is uploaded with file source %s", filepath, file_source)
        # return generated_file_id, file_source
        return file_source

    raise CliError(f"No upload location returned: {initiate_upload_response_json}")


def _populate_file_metadata_req_body(file_source):
    return {
        "kind": "osdu:wks:dataset--File.Generic:1.0.0",
        "acl": {
            "viewers": [],
            "owners": [],
        },
        "legal": {
            "legaltags": [],
            "otherRelevantDataCountries": ["US"],
            "status": "compliant",
        },
        "data": {"DatasetProperties": {"FileSourceInfo": {"FileSource": file_source}}},
    }


def _update_work_products_metadata(
    config: CLIConfig,
    data,
    files,
    simulate,
    legal_tags: list[str],
    acl_owners: list[str],
    acl_viewers: list[str],
):
    if "WorkProduct" in data:
        _update_legal_and_acl_tags(config, data["WorkProduct"], legal_tags, acl_owners, acl_viewers)
    if "WorkProductComponents" in data:
        _update_legal_and_acl_tags_all(
            config, data["WorkProductComponents"], legal_tags, acl_owners, acl_viewers
        )
    if "Datasets" in data:  # pylint: disable=too-many-nested-blocks
        _update_legal_and_acl_tags_all(
            config, data["Datasets"], legal_tags, acl_owners, acl_viewers
        )

        # if files is specified then upload any needed data.
        if files:
            for dataset in data.get("Datasets"):
                file_source_info = (
                    dataset.get("data", {}).get("DatasetProperties", {}).get("FileSourceInfo")
                )
                # only process if FileSource isn't already specified

                if file_source_info:
                    file_path = os.path.join(files, file_source_info["Name"])
                    if os.path.exists(file_path):
                        if not simulate:
                            file_source_info["FileSource"] = _upload_file(config, file_path)
                    else:
                        logger.info(
                            "Local file '%s' not found - skipping.",
                            file_path,
                        )

    # TO DO: Here we scan by name from filemap
    # with open(file_location_map) as file:
    #     location_map = json.load(file)

    # file_name = data["WorkProduct"]["data"]["Name"]
    # if file_name in location_map:
    #     file_source = location_map[file_name]["file_source"]
    #     file_id = location_map[file_name]["file_id"]

    #     # Update Dataset with Generated File Id and File Source.
    #     data["Datasets"][0]["id"] = file_id
    #     data["Datasets"][0]["data"]["DatasetProperties"]["FileSourceInfo"]["FileSource"] = file_source
    #     del data["Datasets"][0]["data"]["DatasetProperties"]["FileSourceInfo"]["PreloadFilePath"]

    #     # Update FileId in WorkProductComponent
    #     data["WorkProductComponents"][0]["data"]["Datasets"][0] = file_id
    # else:
    #     logger.warn(f"Filemap {file_name} does not exist")

    # logger.debug(f"data to upload workproduct \n {data}")


def _update_legal_and_acl_tags_all(
    config: CLIConfig,
    data,
    legal_tags: list[str] = None,
    acl_owners: list[str] = None,
    acl_viewers: list[str] = None,
):
    for _data in data:
        _update_legal_and_acl_tags(config, _data, legal_tags, acl_owners, acl_viewers)


def _update_legal_and_acl_tags(  # noqa: C901
    config: CLIConfig,
    data,
    legal_tags: list[str] = None,
    acl_owners: list[str] = None,
    acl_viewers: list[str] = None,
):
    # Update legal tags if needed
    if legal_tags is not None:
        if len(legal_tags) == 0:
            legal_tags = [config.get("core", CONFIG_LEGAL_TAG)]
        data["legal"]["legaltags"] = legal_tags
    else:
        for legal_tag in data["legal"]["legaltags"]:
            if re.search("^{{.*}}$", legal_tag):
                raise CliError(
                    f"Found a legal tag placeholder {legal_tag}. Use the -l option to replace"
                    " these."
                )

    # Update legal country
    data["legal"]["otherRelevantDataCountries"] = ["US"]

    # Update acl owners tags if needed
    if acl_owners is not None:
        if len(acl_owners) == 0:
            acl_owners = [config.get("core", CONFIG_ACL_OWNER)]
        data["acl"]["owners"] = acl_owners
    else:
        for acl_owner in data["acl"]["owners"]:
            if re.search("^{{.*}}$", acl_owner):
                raise CliError(
                    f"Found an acl owner placeholder {acl_owner}. Use the -aclo option to replace"
                    " these."
                )

    # Update acl viewers if needed
    if acl_viewers is not None:
        if len(acl_viewers) == 0:
            acl_viewers = [config.get("core", CONFIG_ACL_VIEWER)]
        data["acl"]["viewers"] = acl_viewers
    else:
        for acl_viewer in data["acl"]["viewers"]:
            if re.search("^{{.*}}$", acl_viewer):
                raise CliError(
                    f"Found an acl viewer placeholder {acl_viewer}. Use the -aclv option to replace"
                    " these."
                )
</file>

<file path="osducli/commands/dataload/status.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Dataload status command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import handle_cli_exceptions
from osducli.commands.workflow.status import status
from osducli.log import get_logger

# pylint: disable=duplicate-code

START_TIME = "startTimeStamp"
END_TIME = "endTimeStamp"
STATUS = "status"
RUN_ID = "runId"
TIME_TAKEN = "timeTaken"
FINISHED = "finished"
FAILED = "failed"

logger = get_logger(__name__)


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-r", "--runid", help="Runid to query status of.")
@click.option(
    "-rl",
    "--runid-log",
    help="Path to a file containing run ids to get status of (see dataload ingest -h).",
    type=click.Path(exists=True, file_okay=True, readable=True, resolve_path=True),
)
@click.option(
    "-w", "--wait", help="Whether to wait for runs to complete.", is_flag=True, show_default=True
)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State, runid: str = None, runid_log: str = None, wait: bool = False):
    """Get status of workflow runs."""
    return status(state, runid, runid_log, wait)
</file>

<file path="osducli/commands/dataload/verify.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Dataload verify command"""

import json

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_DATA_PARTITION_ID, CONFIG_SEARCH_URL, CLIConfig
from osducli.log import get_logger
from osducli.util.file import get_files_from_path

logger = get_logger(__name__)


# click entry point
@click.command(cls=CustomClickCommand)
@click.option(
    "-p",
    "--path",
    help="Path to a manifest file or files to check.",
    type=click.Path(exists=True, file_okay=True, dir_okay=True, readable=True, resolve_path=True),
    required=True,
)
@click.option("-b", "--batch", help="Batch size.", type=int, default=200, show_default=True)
@click.option(
    "--batch-across-files",
    is_flag=True,
    default=True,
    help="Create batches across files for speed.",
    show_default=True,
)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State, path: str, batch: int = 200, batch_across_files=True):
    """Verify if records exist in OSDU.

    This command will check whether id's in the specified manifest files exist in OSDU.

    Note that this doesn't support versioning - success indicates that a record's id
    is found, however there is no check of the contents so it could be an older version
    if you have done multiple uploads of the same item with different content."""
    return verify(state, path, batch, batch_across_files)


def _create_search_query(record_ids):
    final_query = " OR ".join('"' + x + '"' for x in record_ids)
    final_query = f"id:({final_query})"

    return {
        "kind": "*:*:*:*.*.*",
        "limit": 10000,
        "returnedFields": ["id"],
        "offset": 0,
        "query": final_query,
    }


def _verify_ids(config: CLIConfig, record_ids):
    success = []
    failed = []
    search_query = _create_search_query(record_ids)
    logger.debug("search query %s", json.dumps(search_query))

    connection = CliOsduClient(config)
    response_json = connection.cli_post_returning_json(
        CONFIG_SEARCH_URL, "query?limit=10000", search_query
    )

    logger.debug("search response %s", response_json)
    ingested_records = response_json.get("results")

    for ingested_record in ingested_records:
        success.append(ingested_record.get("id"))

    failed = [x for x in record_ids if x not in success]
    if len(failed) > 0:
        logger.debug(
            "Checked %i records. Could not find %i records with Ids: %s",
            len(record_ids),
            len(failed),
            failed,
        )

    return success, failed


def batch_verify(config, batch_size, ids_to_verify, success, failed, process_all_ids=False):
    """Verify a list of id's in batches"""
    while len(ids_to_verify) >= batch_size or (process_all_ids and len(ids_to_verify) > 0):
        total_size = len(ids_to_verify)
        batch_size = min(batch_size, total_size)
        current_batch = ids_to_verify[:batch_size]
        del ids_to_verify[:batch_size]
        logger.debug(
            "Processing batch - total %i, batch size %i, remaining %i",
            total_size,
            len(current_batch),
            len(ids_to_verify),
        )
        _s, _f = _verify_ids(config, current_batch)

        success.extend(_s)
        failed.extend(_f)


def verify(
    state: State, path: str, batch_size: int, batch_across_files: bool
):  # noqa: C901
    """Verify if records exist in OSDU.

    Args:
        state (State): Global state
        path (str): Path to a file containing run ids to get status of
        batch_size (int): Batch size
        batch_across_files (bool): Create batches across files for speed
    """
    files = get_files_from_path(path)
    logger.debug("Files list: %s", files)

    success = []
    failed = []
    ids_to_verify = []
    for filepath in files:
        if filepath.endswith(".json"):
            with open(filepath, encoding="utf-8") as file:
                json_string = file.read()
                # for reference data do replacements (acl, legal happens later)
                json_string = json_string.replace(
                    "{{NAMESPACE}}", state.config.get("core", CONFIG_DATA_PARTITION_ID)
                )
                data_object = json.loads(json_string)

                logger.info("Processing file %s.", filepath)

                ingested_data = None
                if not data_object:
                    logger.error("Error with file %s. File is empty.", filepath)

                elif "ReferenceData" in data_object:
                    ingested_data = data_object["ReferenceData"]

                elif "MasterData" in data_object:
                    ingested_data = data_object["MasterData"]

                if ingested_data:
                    for ingested_datum in ingested_data:
                        if "id" in ingested_datum:
                            ids_to_verify.append(ingested_datum.get("id"))

                batch_verify(
                    state.config, batch_size, ids_to_verify, success, failed, not batch_across_files
                )

    # If batching across files then there might be records here so clear those.
    if len(ids_to_verify) > 0:
        logger.debug("Searching remaining records with batch size %s", len(ids_to_verify))
        batch_verify(state.config, batch_size, ids_to_verify, success, failed, True)

    if len(failed) == 0:
        print(
            f"All {len(success)} records exist in OSDU.",
        )
    else:
        logger.info("Number of Records that exist in OSDU: %s", len(success))
        logger.info("%i Record IDs that do not exist: %s", len(failed), failed)
</file>

<file path="osducli/commands/entitlements/groups/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Manage groups"""
</file>

<file path="osducli/commands/entitlements/groups/add.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Entitlements groups add command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_ENTITLEMENTS_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-g", "--group", help="Email address of the group", required=True)
@click.option("-d", "--description", help="Description")
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State, group: str, description: str):
    """Add a group."""
    return add_group(state, group, description)


def add_group(state: State, group: str, description: str = None) -> dict:
    """Add a group

    Args:
        state (State): Global state
        group (str): Email address of the group
        description (str): Description for the group

    Returns:
        dict: Response from service
    """
    client = CliOsduClient(state.config)
    request_data = {"name": group}
    if description is not None:
        request_data["description"] = description

    return client.cli_post_returning_json(
        config_url_key=CONFIG_ENTITLEMENTS_URL,
        url_extra_path="groups",
        data=request_data,
        ok_status_codes=[200, 201]
    )
</file>

<file path="osducli/commands/entitlements/groups/delete.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Entitlements groups delete command"""

import click

from osducli.click_cli import CustomClickCommand, State, global_params
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_ENTITLEMENTS_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-g", "--group", help="Email address of the group", required=True)
@handle_cli_exceptions
@global_params
def _click_command(state: State, group: str):
    """Delete a group."""
    delete_group(state, group)


def delete_group(state: State, group: str):
    """Delete a group

    Args:
        state (State): Global state
        group (str): Unique email identifier of the group
    """
    client = CliOsduClient(state.config)
    client.cli_delete(
        config_url_key=CONFIG_ENTITLEMENTS_URL,
        url_extra_path=f"groups/{group}",
        ok_status_codes=[200, 204]
    )

    if state.is_user_friendly_mode():
        print("1 group deleted")
</file>

<file path="osducli/commands/entitlements/groups/members.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Entitlements groups members command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_ENTITLEMENTS_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-g", "--group", help="Email address of the group", required=True)
@handle_cli_exceptions
@command_with_output("members[*]")
def _click_command(state: State, group: str):
    """List members in a group."""
    return list_group_members(state, group)


def list_group_members(state: State, group: str) -> dict:
    """Delete members from a group

    Args:
        state (State): Global state
        group (str): Email address of the group

    Returns:
        dict: Response from service
    """
    client = CliOsduClient(state.config)
    return client.cli_get_returning_json(
        config_url_key=CONFIG_ENTITLEMENTS_URL,
        url_extra_path=f"groups/{group}/members"
    )
</file>

<file path="osducli/commands/entitlements/members/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Manage members"""
</file>

<file path="osducli/commands/entitlements/members/add.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Entitlements add member command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_ENTITLEMENTS_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-m", "--member", help="Email of the member to be added.", required=True)
@click.option("-g", "--group", help="Email address of the group", required=True)
@click.option(
    "-r",
    "--role",
    type=click.Choice(["MEMBER", "OWNER"], case_sensitive=False),
    help="Members role",
    default="MEMBER",
    show_default=True,
)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State, member: str, group: str, role: str):
    """Add members to a group."""
    return add_member(state, member, group, role)


def add_member(state: State, member: str, group: str, role: str) -> dict:
    """Add members to a group.

    Args:
        state (State): Global state
        member (str): Email address of the member
        group (str): Email address of the group
        role (str): Members role

    Returns:
        dict: Response from service
    """
    client = CliOsduClient(state.config)
    request_data = {
        "email": member,
        "role": role,
    }
    return client.cli_post_returning_json(
        config_url_key=CONFIG_ENTITLEMENTS_URL,
        url_extra_path=f"groups/{group}/members",
        data=request_data
    )
</file>

<file path="osducli/commands/entitlements/members/groups.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Entitlements members groups command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_ENTITLEMENTS_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-m", "--member", help="Email of the member to show groups for.", required=True)
@handle_cli_exceptions
@command_with_output("groups[*]")
def _click_command(state: State, member: str):
    """List groups a member belongs to."""

    client = CliOsduClient(state.config)
    return client.cli_get_returning_json(
        config_url_key=CONFIG_ENTITLEMENTS_URL,
        url_extra_path=f"members/{member}/groups?type=none"
    )
</file>

<file path="osducli/commands/entitlements/members/list.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Entitlements my groups command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import handle_cli_exceptions

from ..groups.members import list_group_members


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-g", "--group", help="Email address of the group", required=True)
@handle_cli_exceptions
@command_with_output("members[*]")
def _click_command(state: State, group: str):
    """List members in a group."""
    return list_group_members(state, group)
</file>

<file path="osducli/commands/entitlements/members/remove.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Entitlements my groups command"""

import click

from osducli.click_cli import CustomClickCommand, State, global_params
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_ENTITLEMENTS_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-m", "--member", help="Email of the member to be remove.", required=True)
@click.option("-g", "--group", help="Email address of the group", required=True)
@handle_cli_exceptions
@global_params
def _click_command(state: State, member: str, group: str):
    """Remove member from a group."""
    return remove_member(state, member, group)


def remove_member(state: State, member: str, group: str) :
    """ Remove member from a group.

    Args:
        state (State): Global state
        member (str): Email address of the member
        group (str): Email address of the group
    """
    client = CliOsduClient(state.config)
    client.cli_delete(
        config_url_key=CONFIG_ENTITLEMENTS_URL,
        url_extra_path=f"groups/{group}/members/{member}",
        ok_status_codes=[204]
    )

    if state.is_user_friendly_mode():
        print("1 member removed from group")
</file>

<file path="osducli/commands/entitlements/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Entitlement service commands"""
</file>

<file path="osducli/commands/entitlements/_const.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Entitlements constants"""

ENTITLEMENTS_SERVICE_NAME = "Entitlements Service"
ENTITLEMENTS_STATUS_PATH = "_ah/readiness_check"
ENTITLEMENTS_SWAGGER_PATH = "swagger-ui.html"
ENTITLEMENTS_DOCUMENTATION = "https://community.opengroup.org/osdu/platform/security-and-compliance/entitlements/-/blob/master/docs/tutorial/Entitlements-Service.md"  # noqa: E501
</file>

<file path="osducli/commands/entitlements/info.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Entitlements info command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import handle_cli_exceptions
from osducli.commands.entitlements._const import (
    ENTITLEMENTS_DOCUMENTATION,
    ENTITLEMENTS_SERVICE_NAME,
    ENTITLEMENTS_STATUS_PATH,
    ENTITLEMENTS_SWAGGER_PATH,
)
from osducli.config import CONFIG_ENTITLEMENTS_URL
from osducli.util.service_info import info


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State) -> dict:
    """Information about the service"""
    return info(
        state,
        ENTITLEMENTS_SERVICE_NAME,
        CONFIG_ENTITLEMENTS_URL,
        ENTITLEMENTS_STATUS_PATH,
        ENTITLEMENTS_SWAGGER_PATH,
        ENTITLEMENTS_DOCUMENTATION,
    )
</file>

<file path="osducli/commands/entitlements/mygroups.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Entitlements my groups command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output("groups[*]")
def _click_command(state: State):
    """List groups you have access to."""
    return list_my_groups(state)


def list_my_groups(state: State) -> dict:
    """Get the calling users groups

    Args:
        state (State): Global state

    Returns:
        dict: Response from service
    """
    client = CliOsduClient(state.config)
    entitlements_client = client.get_entitlements_client()
    response = entitlements_client.get_groups_for_user()
    return response.json()
</file>

<file path="osducli/commands/file/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""File service commands"""
</file>

<file path="osducli/commands/file/_const.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""CRS constants"""

FILE_DOCUMENTATION = None
FILE_SERVICE_NAME = "File service"
FILE_STATUS_PATH = "readiness_check"
FILE_SWAGGER_PATH = "../swagger-ui.html"
</file>

<file path="osducli/commands/file/download.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""file download command"""

import click
import requests

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_FILE_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-id", "--id", "_id", help="id to download", required=True)
@click.option(
    "-p",
    "--path",
    help="Path to download the file to.",
    type=click.Path(file_okay=True, dir_okay=False, writable=True, resolve_path=True),
    required=True,
)
@handle_cli_exceptions
@command_with_output(
    # "crses[].{Name:aliasNames[0],Authority:baseCRSAuthorityCode.auth,Code:baseCRSAuthorityCode.code,Type:crstype,Source:source}"  # noqa: E501
)
def _click_command(state: State, _id: str, path: str):
    """Download a file"""
    return file_download(state, _id, path)


def file_download(state: State, _id: str, path: str):
    """List coordinate referense systems

    Args:
        state (State): Global state
        path (str): path to download the file to
    """
    connection = CliOsduClient(state.config)
    json = connection.cli_get_returning_json(CONFIG_FILE_URL, f"files/{_id}/downloadURL")
    signed_url = json["SignedUrl"]

    # pylint: disable=missing-timeout
    with requests.get(signed_url, stream=True) as response:
        response.raise_for_status()
        with open(path, "wb") as file:
            for chunk in response.iter_content(chunk_size=8192):
                file.write(chunk)

    return json
</file>

<file path="osducli/commands/file/info.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""CRS Catalog info command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import handle_cli_exceptions
from osducli.commands.file._const import (
    FILE_DOCUMENTATION,
    FILE_SERVICE_NAME,
    FILE_STATUS_PATH,
    FILE_SWAGGER_PATH,
)
from osducli.config import CONFIG_FILE_URL
from osducli.util.service_info import info


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State) -> dict:
    """Information about the service"""
    return info(
        state,
        FILE_SERVICE_NAME,
        CONFIG_FILE_URL,
        FILE_STATUS_PATH,
        FILE_SWAGGER_PATH,
        FILE_DOCUMENTATION,
    )
</file>

<file path="osducli/commands/file/metadata.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""File metadata command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_FILE_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-id", "--id", "_id", help="id to get metadata for", required=True)
@handle_cli_exceptions
@command_with_output()
def _click_command(state: State, _id: str):
    """Get file metadata"""
    return file_metadata(state, _id)


def file_metadata(state: State, _id: str):
    client = CliOsduClient(state.config)
    json = client.cli_get_returning_json(CONFIG_FILE_URL, f"files/{_id}/metadata")
    return json
</file>

<file path="osducli/commands/legal/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Legal service commands"""
</file>

<file path="osducli/commands/legal/_const.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Legal constants"""

LEGAL_SERVICE_NAME = "Legal service"
LEGAL_STATUS_PATH = "_ah/readiness_check"
LEGAL_SWAGGER_PATH = "swagger-ui.html"
LEGAL_DOCUMENTATION = "https://community.opengroup.org/osdu/platform/security-and-compliance/legal/-/blob/master/docs/tutorial/ComplianceService.md"  # noqa: E501
</file>

<file path="osducli/commands/legal/add.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Legal service add command"""

import json

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_LEGAL_URL
from osducli.log import get_logger

logger = get_logger(__name__)


# click entry point
@click.command(cls=CustomClickCommand)
@click.option(
    "-p",
    "--path",
    help="Path to a json file with the legal tag to add.",
    type=click.Path(exists=True, file_okay=True, dir_okay=False, readable=True, resolve_path=True),
    required=True,
)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State, path: str):
    """Add a legal tag"""
    return add_legal_tag(state, path)


def add_legal_tag(state: State, path: str) -> dict:
    """Add a legal tag

    Args:
        state (State): Global state
        path (str): Path to json file with the legal tag to add.
    Returns:
        dict: Response from service
    """
    connection = CliOsduClient(state.config)

    if path.endswith(".json"):
        with open(path, encoding="utf-8") as file:
            payload = json.load(file)
            response_json = None
            response_json = connection.cli_post_returning_json(
                CONFIG_LEGAL_URL, "legaltags", payload, [200, 201]
            )
            return response_json
    else:
        print(f"{path} must be a json file and have a .json extension")

    return None
</file>

<file path="osducli/commands/legal/delete.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Legal service delete command"""

import click

from osducli.click_cli import CustomClickCommand, State, global_params
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_LEGAL_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-n", "--name", required=True, help="Name of tag to delete")
@handle_cli_exceptions
@global_params
def _click_command(state: State, name: str):
    """Delete legal tag"""
    return delete(state, name)


def delete(state: State, name: str):
    """Delete legal tag

    Args:
        state (State): Global state
        name (str): Name of legal tag to delete
    """
    connection = CliOsduClient(state.config)
    url = "legaltags/" + name
    connection.cli_delete(CONFIG_LEGAL_URL, url, [204])

    if state.is_user_friendly_mode():
        print("1 legal tag deleted")
</file>

<file path="osducli/commands/legal/info.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Legal service info command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import handle_cli_exceptions
from osducli.commands.legal._const import (
    LEGAL_DOCUMENTATION,
    LEGAL_SERVICE_NAME,
    LEGAL_STATUS_PATH,
    LEGAL_SWAGGER_PATH,
)
from osducli.config import CONFIG_LEGAL_URL
from osducli.util.service_info import info


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State) -> dict:
    """Information about the service"""
    return info(
        state,
        LEGAL_SERVICE_NAME,
        CONFIG_LEGAL_URL,
        LEGAL_STATUS_PATH,
        LEGAL_SWAGGER_PATH,
        LEGAL_DOCUMENTATION,
    )
</file>

<file path="osducli/commands/legal/listtags.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Legal service list tags commands"""
import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_LEGAL_URL


@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output(
    "legalTags[*].{Name:name,Description:description,Classification:properties.securityClassification,PersonalData:properties.personalData,Export:properties.exportClassification,Origin:properties.originator}"  # noqa: E501
)
def _click_command(state: State):
    """List legal tags"""

    return list_tags(state)


def list_tags(state: State):
    """[summary]

    Args:
        state (State): Global state
    """
    connection = CliOsduClient(state.config)
    json_response = connection.cli_get_returning_json(CONFIG_LEGAL_URL, "legaltags")

    return json_response
</file>

<file path="osducli/commands/list/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""List different types of information."""
</file>

<file path="osducli/commands/list/records.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Custom cluster upgrade specific commands"""
import click
from osdu_api.model.search.query_request import QueryRequest

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions


@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output("sort_by(aggregations,&key)[*].{Key:key,Count:count}")
def _click_command(state: State):
    """List count of populated records"""

    return records(state)


def records(state: State):
    """[summary]

    Args:
        state (State): Global state
    """
    client = CliOsduClient(state.config)
    search_client = client.get_search_client()
    query_request = QueryRequest(kind='*:*:*:*', query='*', limit=1, aggregate_by='kind')
    response = search_client.query_records(query_request=query_request)
    client.check_status_code(response)
    return response.json()
</file>

<file path="osducli/commands/schema/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Schema service commands"""
</file>

<file path="osducli/commands/schema/_const.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Schema constants"""

SCHEMA_SERVICE_NAME = "Schema service"
SCHEMA_STATUS_PATH = "schema?limit=1"
SCHEMA_SWAGGER_PATH = "swagger-ui.html"
SCHEMA_DOCUMENTATION = "https://community.opengroup.org/osdu/platform/system/schema-service/-/blob/master/docs/SchemaService-OSDU.md"  # noqa: E501
</file>

<file path="osducli/commands/schema/add.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Version command"""

import json
import os
from pathlib import Path

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_SCHEMA_URL
from osducli.log import get_logger
from osducli.util.exceptions import CliError
from osducli.util.file import get_files_from_path

logger = get_logger(__name__)


# click entry point
@click.command(cls=CustomClickCommand)
@click.option(
    "-p",
    "--path",
    help="Path to a schema or schemas to add.",
    required=True,
)
@click.option(
    "-k",
    "--kind",
    help="Kind of the schema. Inferred from schemaInfo property if not specified.",
)
@click.option(
    "--status",
    help="Status of the schema.",
    default="DEVELOPMENT",
    show_default=True,
)
@click.option(
    "--overwrite-existing",
    help="Overwrite any existing schema with the same version.",
    is_flag=True,
    show_default=True,
)
@click.option(
    "--self-contained",
    help="Make the schema self contained by including all references.",
    is_flag=True,
    show_default=True,
)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(
    state: State, path: str, kind: str, status: str, overwrite_existing: bool, self_contained: bool
):
    """Add a schema"""
    return add_schema(state, path, kind, status, overwrite_existing, self_contained)


def add_schema(
    state: State, path: str, kind: str, status: str, overwrite_existing: bool, self_contained: bool
) -> dict:
    """Add schemas to OSDU

    Args:
        state (State): Global state
        path (str): Path to a schema or schemas to add.
        kind (str): Kind of the schema.
        status (str): Status of the schema.
        overwrite_existing (bool): Overwrite any existing schema
        self_contained (bool): Make the schema self contained by including all references.

    Returns:
        dict: Response from service
    """
    connection = CliOsduClient(state.config)
    url = "schema"

    files = get_files_from_path(path)
    logger.debug("Files list: %s", files)

    responses = []
    for filepath in files:
        if filepath.endswith(".json"):
            with open(filepath, encoding="utf-8") as file:
                schema_object = json.load(file)

                logger.info("Processing file %s.", filepath)

                if kind is None:
                    if "x-osdu-schema-source" in schema_object:
                        kind = schema_object["x-osdu-schema-source"]
                        logger.debug("Kind determined as %s", kind)

                #     kind = _kind_from_schema_info(schema_object)
                if kind is None:
                    raise CliError(
                        f"Kind not specified for {filepath} and could not determine schema"
                        " kind from schemaInfo property."
                    )

                if self_contained:
                    _make_self_contained(schema_object, Path(filepath).parent)
                schema_info = _get_schema_info(kind, status)
                payload = {"schemaInfo": schema_info, "schema": schema_object}

                response_json = None
                if overwrite_existing:
                    response_json = connection.cli_put_returning_json(
                        CONFIG_SCHEMA_URL, url, payload, [200, 201]
                    )
                else:
                    response_json = connection.cli_post_returning_json(
                        CONFIG_SCHEMA_URL, url, payload, [200, 201]
                    )
                responses.append(response_json)

    return responses


def _make_self_contained(schema_object, folder):
    all_references = set()
    # references_to_check = set()

    # _get_refs_in_schema_recursive(schema_object, None, all_references, None)

    # check_new_refs(schema_object, folder, all_references)

    # while len(references_to_check) > 0:
    #     ref = references_to_check.pop()
    #     if ref not in all_references:
    #         referenced_file_path = folder.joinpath(ref)
    #         with open(referenced_file_path) as referenced_file:
    #             referenced_schema_object = json.load(referenced_file)
    #             schema_object["definitions"][path_to_reference(ref)] = referenced_schema_object
    #         check_new_refs(schema_object, folder, all_references)

    #         pass

    if "definitions" not in schema_object:
        schema_object["definitions"] = {}
    for ref in all_references:
        referenced_file_path = folder.joinpath(ref)
        with open(referenced_file_path, encoding="utf-8") as referenced_file:
            referenced_schema_object = json.load(referenced_file)

            schema_object["definitions"][_path_to_reference(ref)] = referenced_schema_object
    print(json.dumps(schema_object))
    return all_references


def _check_new_refs(schema_object, filepath, all_references):
    for ref in all_references:
        referenced_file_path = Path(filepath).parent.joinpath(ref)
        new_references = set()
        _get_refs_in_schema_recursive(schema_object, None, new_references, None)
        new_references = new_references - all_references
        with open(referenced_file_path, encoding="utf-8") as referenced_file:
            referenced_schema_object = json.load(referenced_file)
            schema_object["definitions"][_path_to_reference(ref)] = referenced_schema_object


def _get_refs_in_schema_recursive(obj, key, refs, parent):
    if isinstance(obj, dict):
        for _k, _v in obj.items():
            _get_refs_in_schema_recursive(_v, _k, refs, obj)
    elif isinstance(obj, list):
        for list_item in obj:
            _get_refs_in_schema_recursive(list_item, None, refs, obj)
    elif key == "$ref":
        refs.add(obj)
        parent[key] = f"#/definitions/{_path_to_reference(obj)}"


def _path_to_reference(obj):
    ref = (
        "osdu:wks:" + os.path.splitext(os.path.basename(obj))[0]
    )  # obj.replace("../abstract/", "").replace(".json", "")
    return ref


def _get_schema_info(kind: str, status: str):
    kind_parts = kind.split(":")
    if len(kind_parts) != 4:
        raise CliError(
            f"Kind '{kind}' is not in the correct format 'authority:source:entity:v:v:v'"
        )
    version = kind_parts[3].split(".")
    if len(version) != 3:
        raise CliError(
            f"Kind '{kind}' is not in the correct format 'authority:source:entity:v:v:v'"
        )

    schema_info = {
        "schemaIdentity": {
            "authority": kind_parts[0],
            "source": kind_parts[1],
            "entityType": kind_parts[2],
            "schemaVersionMajor": version[0],
            "schemaVersionMinor": version[1],
            "schemaVersionPatch": version[2],
        },
        "createdBy": "osducli",
        "status": status,
    }
    return schema_info


def _kind_from_schema_info(schema: dict) -> str:
    try:  # pylint: disable=too-many-try-statements
        _si = schema.get("schemaInfo", {}).get("schemaIdentity", {})
        authority = _si.get("authority", "")
        source = _si.get("source", "")
        entity = _si.get("entityType", "")
        major = str(_si.get("schemaVersionMajor", 0))
        minor = str(_si.get("schemaVersionMinor", 0))
        patch = str(_si.get("schemaVersionPatch", 0))
        return f"{authority}:{source}:{entity}:{major}.{minor}.{patch}"
    except Exception:  # pylint: disable=broad-except
        return None
</file>

<file path="osducli/commands/schema/get.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Schema service list command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_SCHEMA_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-k", "--kind", required=True, help="Kind of the schema")
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State, kind: str):
    """Get schema"""
    return schema_get(state, kind)


def schema_get(state: State, kind: str):
    """Get schema

    Args:
        state (State): Global state
        kind (str): Kind of the schema
    """
    connection = CliOsduClient(state.config)
    url = "schema/" + kind
    json = connection.cli_get_returning_json(CONFIG_SCHEMA_URL, url)
    return json
</file>

<file path="osducli/commands/schema/info.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Schema info command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import handle_cli_exceptions
from osducli.commands.schema._const import (
    SCHEMA_DOCUMENTATION,
    SCHEMA_SERVICE_NAME,
    SCHEMA_STATUS_PATH,
    SCHEMA_SWAGGER_PATH,
)
from osducli.config import CONFIG_SCHEMA_URL
from osducli.util.service_info import info


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State) -> dict:
    """Information about the service"""
    return info(
        state,
        SCHEMA_SERVICE_NAME,
        CONFIG_SCHEMA_URL,
        SCHEMA_STATUS_PATH,
        SCHEMA_SWAGGER_PATH,
        SCHEMA_DOCUMENTATION,
    )
</file>

<file path="osducli/commands/schema/list.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Schema service list command"""

from urllib.parse import quote_plus

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_SCHEMA_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-a", "--authority", help="Authority to filter by")
@click.option("-e", "--entity", help="Entity to filter by")
@click.option("-s", "--source", help="Source to filter by")
@handle_cli_exceptions
@command_with_output(
    "sort_by(schemaInfos[].schemaIdentity[].{id:id,Authority:authority,Source:source,Entity:entityType,MajorVersion:schemaVersionMajor,MinorVersion:schemaVersionMinor,PatchVersion:schemaVersionPatch},&id)"  # noqa: E501
)
def _click_command(state: State, authority: str = None, entity: str = None, source: str = None):
    """List schemas"""
    return schema_list(state, authority, entity, source)


def schema_list(state: State, authority: str, entity: str, source: str):
    """List schemas

    Args:
        state (State): Global state
        authority (str): Global state
        entity (str): Global state
        source (str): Global state
    """
    connection = CliOsduClient(state.config)
    url = "schema?limit=10000"
    if authority:
        url += "&authority=" + quote_plus(authority)
    if entity:
        url += "&entity=" + quote_plus(entity)
    if source:
        url += "&source=" + quote_plus(source)
    json = connection.cli_get_returning_json(CONFIG_SCHEMA_URL, url)
    return json
</file>

<file path="osducli/commands/search/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Search service commands"""
</file>

<file path="osducli/commands/search/_const.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Search constants"""

SEARCH_SERVICE_NAME = "Search service"
SEARCH_STATUS_PATH = "liveness_check"
SEARCH_SWAGGER_PATH = "swagger-ui.html"
SEARCH_DOCUMENTATION = "https://community.opengroup.org/osdu/platform/system/search-service/-/blob/master/docs/tutorial/SearchService.md"  # noqa: E501
</file>

<file path="osducli/commands/search/id.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Search service query command"""

import click
from osdu_api.model.search.query_request import QueryRequest

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions


# click entry point
@click.command(cls=CustomClickCommand)
@click.argument("id")
@click.option(
    "-l",
    "--limit",
    "limit",
    default=10,
    show_default=True,
    help="maximum number of records to return.",
)
@handle_cli_exceptions
@command_with_output("results[*]")
def _click_command(state: State, id: str, limit: int):  # noqa:W1 pylint: disable=invalid-name,redefined-builtin
    """Search for the specified id"""
    return query(state, id, limit)


def query(state: State, identifier: str, limit: int):
    """Search for the specified id

    Args:
        state (State): Global state
        identifier (str): id to search for
        limit (int): maximum number of records to return
    """
    client = CliOsduClient(state.config)
    search_client = client.get_search_client()
    query_request = QueryRequest(kind="*:*:*:*",
                                 query=f'id:("{identifier}")',
                                 limit=limit)
    response = search_client.query_records(query_request=query_request)
    client.check_status_code(response)
    return response.json()
</file>

<file path="osducli/commands/search/info.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Search info command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import handle_cli_exceptions
from osducli.commands.search._const import (
    SEARCH_DOCUMENTATION,
    SEARCH_SERVICE_NAME,
    SEARCH_STATUS_PATH,
    SEARCH_SWAGGER_PATH,
)
from osducli.config import CONFIG_SEARCH_URL
from osducli.util.service_info import info


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State) -> dict:
    """Information about the service"""
    return info(
        state,
        SEARCH_SERVICE_NAME,
        CONFIG_SEARCH_URL,
        SEARCH_STATUS_PATH,
        SEARCH_SWAGGER_PATH,
        SEARCH_DOCUMENTATION,
    )
</file>

<file path="osducli/commands/search/kind.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Search service query command"""

import click
from osdu_api.model.search.query_request import QueryRequest

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions


# click entry point
@click.command(cls=CustomClickCommand)
@click.argument("kind")
@click.option(
    "-l",
    "--limit",
    "limit",
    default=10,
    show_default=True,
    help="maximum number of records to return.",
)
@handle_cli_exceptions
@command_with_output("results[*]")
def _click_command(
    state: State, kind: str, limit: int
):  # noqa:W1
    """Search for items of the specified kind"""
    return query(state, kind, limit)


def query(state: State, kind: str, limit: int):
    """Search for the specified kind

    Args:
        state (State): Global state
        kind (str): Kind to search for
        limit (int): Maximum number of records to return
    """
    client = CliOsduClient(state.config)
    search_client = client.get_search_client()
    query_request = QueryRequest(kind=kind, query='', limit=limit)
    response = search_client.query_records(query_request=query_request)
    client.check_status_code(response)
    return response.json()
</file>

<file path="osducli/commands/search/query.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Search service query command"""

import click
from osdu_api.model.search.query_request import QueryRequest

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-k", "--kind", "kind", help="kind to search for")
@click.option("-id", "--id", "_id", help="id to search for")
@click.option("-q", "--query", "_query", help="custom search query")
@click.option(
    "-l",
    "--limit",
    "limit",
    default=10,
    show_default=True,
    help="maximum number of records to return.",
)
@handle_cli_exceptions
@command_with_output("results[*].{Id:id,Kind:kind,CreateTime:createTime}")
def _click_command(state: State, kind: str, _id: str, _query: str, limit: int):
    """Search using more advanced query terms"""
    return query(state, kind, _id, _query, limit)


def query(state: State, kind: str, identifier: str, custom_query: str, limit: int):
    """Query search service

    Args:
        state (State): Global state
        kind (str): kind to search for
        identifier (str): id to search for
        custom_query (str): custom search query
        limit (int): maximum number of records to return.
    """
    client = CliOsduClient(state.config)
    search_client = client.get_search_client()

    if identifier is not None and custom_query is not None:
        raise ValueError("You can't specify both identifier and query")

    if kind is None:
        kind = "*:*:*:*"

    query_val = f'id:("{identifier}")' if identifier is not None else custom_query
    request_data = QueryRequest(kind=kind, query=query_val, limit=limit)

    response = search_client.query_records(query_request=request_data)
    client.check_status_code(response)
    return response.json()
</file>

<file path="osducli/commands/status/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Shows the status of OSDU services."""
</file>

<file path="osducli/commands/status/status.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Code to handle status commands"""

import click
from requests.exceptions import RequestException

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.commands.crs._const import (
    CRS_CATALOG_SERVICE_NAME,
    CRS_CATALOG_STATUS_PATH,
    CRS_CONVERTER_SERVICE_NAME,
    CRS_CONVERTER_STATUS_PATH,
)
from osducli.commands.entitlements._const import (
    ENTITLEMENTS_SERVICE_NAME,
    ENTITLEMENTS_STATUS_PATH,
)
from osducli.commands.file._const import FILE_SERVICE_NAME, FILE_STATUS_PATH
from osducli.commands.legal._const import LEGAL_SERVICE_NAME, LEGAL_STATUS_PATH
from osducli.commands.schema._const import SCHEMA_SERVICE_NAME, SCHEMA_STATUS_PATH
from osducli.commands.search._const import SEARCH_SERVICE_NAME, SEARCH_STATUS_PATH
from osducli.commands.storage._const import STORAGE_SERVICE_NAME, STORAGE_STATUS_PATH
from osducli.commands.unit._const import UNIT_SERVICE_NAME, UNIT_STATUS_PATH
from osducli.commands.wellbore_ddms._const import (
    WELLBORE_DDMS_SERVICE_NAME,
    WELLBORE_DDMS_STATUS_PATH,
)
from osducli.commands.workflow._const import WORKFLOW_SERVICE_NAME, WORKFLOW_STATUS_PATH
from osducli.config import (
    CONFIG_CRS_CATALOG_URL,
    CONFIG_CRS_CONVERTER_URL,
    CONFIG_ENTITLEMENTS_URL,
    CONFIG_FILE_URL,
    CONFIG_LEGAL_URL,
    CONFIG_SCHEMA_URL,
    CONFIG_SEARCH_URL,
    CONFIG_STORAGE_URL,
    CONFIG_UNIT_URL,
    CONFIG_WELLBORE_DDMS_URL,
    CONFIG_WORKFLOW_URL,
)
from osducli.log import get_logger

logger = get_logger(__name__)


@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output("results[]")
def _click_command(state: State):
    # def _click_command(ctx, debug, config, hostname):
    """Shows the status of OSDU services"""
    return status(state)


def status(state: State):
    """status command entry point

    User friendly mode displays results as received for responsiveness.
    Args:
        state (State): Global state
    """
    connection = CliOsduClient(state.config)
    results = []
    services = [
        (CRS_CATALOG_SERVICE_NAME, CONFIG_CRS_CATALOG_URL, CRS_CATALOG_STATUS_PATH),
        (CRS_CONVERTER_SERVICE_NAME, CONFIG_CRS_CONVERTER_URL, CRS_CONVERTER_STATUS_PATH),
        (FILE_SERVICE_NAME, CONFIG_FILE_URL, FILE_STATUS_PATH),
        (ENTITLEMENTS_SERVICE_NAME, CONFIG_ENTITLEMENTS_URL, ENTITLEMENTS_STATUS_PATH),
        (LEGAL_SERVICE_NAME, CONFIG_LEGAL_URL, LEGAL_STATUS_PATH),
        (SCHEMA_SERVICE_NAME, CONFIG_SCHEMA_URL, SCHEMA_STATUS_PATH),
        (SEARCH_SERVICE_NAME, CONFIG_SEARCH_URL, SEARCH_STATUS_PATH),
        (STORAGE_SERVICE_NAME, CONFIG_STORAGE_URL, STORAGE_STATUS_PATH),
        (UNIT_SERVICE_NAME, CONFIG_UNIT_URL, UNIT_STATUS_PATH),
        (WELLBORE_DDMS_SERVICE_NAME, CONFIG_WELLBORE_DDMS_URL, WELLBORE_DDMS_STATUS_PATH),
        (WORKFLOW_SERVICE_NAME, CONFIG_WORKFLOW_URL, WORKFLOW_STATUS_PATH),
    ]
    for service in services:
        result = check_status(connection, service[0], service[1], service[2])
        results.append(result)
        if state.is_user_friendly_mode():
            print(f"{result['name'].ljust(20)} {result['status']}\t {result['reason']}")

    return None if state.is_user_friendly_mode() else {"results": results}


def check_status(connection: CliOsduClient, name: str, config_url_key: str, url_extra_path: str):
    """Check the status of the given service"""
    try:
        response = connection.cli_get(config_url_key, url_extra_path)
        _status = response.status_code
        _reason = response.reason
    except RequestException as _ex:
        exception_message = str(_ex) if len(str(_ex)) > 0 else "Unknown Error"
        logger.debug(exception_message)
        _status = _ex.response.status_code if _ex.response else -1
        _reason = _ex.response.reason if _ex.response else exception_message

    result = {"name": name, "status": _status, "reason": _reason}
    return result
</file>

<file path="osducli/commands/storage/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Storage service commands"""
</file>

<file path="osducli/commands/storage/_const.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Storage constants"""

STORAGE_SERVICE_NAME = "Storage service"
STORAGE_STATUS_PATH = "liveness_check"
STORAGE_SWAGGER_PATH = "swagger-ui.html"
STORAGE_DOCUMENTATION = "https://community.opengroup.org/osdu/platform/system/storage/-/blob/master/docs/tutorial/StorageService.md"  # noqa: E501
</file>

<file path="osducli/commands/storage/add.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Version command"""

import json

import click
from osdu_api.model.storage.record import Record

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.log import get_logger
from osducli.util.file import get_files_from_path_with_suffix

logger = get_logger(__name__)


# click entry point
@click.command(cls=CustomClickCommand)
@click.option(
    "-p",
    "--path",
    help="Path to a record or records to add.",
    type=click.Path(exists=True, file_okay=True, dir_okay=True, readable=True, resolve_path=True),
    required=True,
)
@click.option(
    "-b",
    "--batch",
    help="Number of records to add per API call. If not specified records are uploaded as is.",
    is_flag=False,
    flag_value=200,
    type=int,
    default=None,
    show_default=True,
)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State, path: str, batch: int):
    """Add or update a record"""
    return add_records(state, path, batch)


def add_records(state: State, path: str, batch: int = None):
    """Add or update a record

    Args:
        state (State): Global state
        path (str): Path to a record or records to add.
        batch (int): Batch size per API call. If None then ingest as is
    """
    client = CliOsduClient(state.config)
    record_client = client.get_storage_record_client()

    files = get_files_from_path_with_suffix(path, ".json")
    logger.debug("Files list: %s", files)

    if batch is not None:
        logger.info("Batching records with size %s", batch)
        file_batches = chunk_list(files, batch)
        for file_batch in file_batches:
            response = add_record_batch(record_client, file_batch)
            handle_response(client, response)
    else:
        response = add_record_batch(record_client, files)
        handle_response(client, response)


def add_record_batch(record_client, files):
    record_list = []
    for filepath in files:
        with open(filepath, encoding="utf-8") as file:
            storage_object = json.load(file)

            logger.info("Processing file %s.", filepath)
            record_list.append(Record.from_dict(storage_object))

    return record_client.create_update_records(record_list)


def chunk_list(lst, size):
    return [lst[i:i + size] for i in range(0, len(lst), size)]


def handle_response(client, response):
    client.check_status_code(response, [200, 201])
    response_json = response.json()
    count = response_json["recordCount"]
    added = response_json["recordIds"]
    skipped = response_json.get("skippedRecordIds", [])

    print(f"Record count: {count}")
    print(json.dumps(added, indent=2))

    if skipped:
        print("Skipped records:")
        print(json.dumps(skipped, indent=2))
</file>

<file path="osducli/commands/storage/delete.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Storage service delete command"""

import click

from osducli.click_cli import CustomClickCommand, State, global_params
from osducli.cliclient import CliOsduClient, handle_cli_exceptions


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-id", "--id", "_id", required=True, help="id to delete")
@handle_cli_exceptions
@global_params
def _click_command(state: State, _id: str):
    """Delete records"""
    return delete(state, _id)


def delete(state: State, id: str):  # pylint: disable=invalid-name,redefined-builtin
    """Delete records

    Args:
        state (State): Global state
        id (str): id to delete
    """
    client = CliOsduClient(state.config)
    record_client = client.get_storage_record_client()
    # TODO: Fix bug in SDK for DELETE. Workaround is to give bearer_token
    response = record_client.delete_record(recordId=id, bearer_token=client.token_refresher.refresh_token())
    client.check_status_code(response, [200, 204])

    if state.is_user_friendly_mode():
        print("1 record deleted")
</file>

<file path="osducli/commands/storage/get.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Storage service get command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_STORAGE_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-k", "--kind", help="Get records by kind")
@click.option("-id", "--id", "_id", help="An id to search for")
@handle_cli_exceptions
@command_with_output("results || {Id:id,Version:version,Kind:kind,CreateUser:createUser,CreateTime:createTime}")
def _click_command(state: State, kind: str, _id: str):
    """Get records"""
    return get(state, kind, _id)


def get(
    state: State, kind: str = None, id: str = None
):  # pylint: disable=invalid-name,redefined-builtin
    """Get records

    Args:
        state (State): Global state
        kind (str): Kind of records
        id (str): Id of records
    """
    client = CliOsduClient(state.config)
    record_client = client.get_storage_record_client()
    response = None

    # NOTE: there is a difference between records and query endpoints
    # url = "records/id"
    # url = "query/records?limit=10000&kind=osdu:wks:work-product-component--WellLog:1.0.0"

    if kind is None and id is None:
        raise ValueError("You must specify either a kind or id")

    if kind is not None:
        response = client.cli_get(CONFIG_STORAGE_URL, f"query/records?kind={kind}")

    if id is not None:
        response = record_client.query_record(id)

    client.check_status_code(response)
    return response.json()
</file>

<file path="osducli/commands/storage/info.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Storage info command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import handle_cli_exceptions
from osducli.commands.storage._const import (
    STORAGE_DOCUMENTATION,
    STORAGE_SERVICE_NAME,
    STORAGE_STATUS_PATH,
    STORAGE_SWAGGER_PATH,
)
from osducli.config import CONFIG_STORAGE_URL
from osducli.util.service_info import info


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State) -> dict:
    """Information about the service"""
    return info(
        state,
        STORAGE_SERVICE_NAME,
        CONFIG_STORAGE_URL,
        STORAGE_STATUS_PATH,
        STORAGE_SWAGGER_PATH,
        STORAGE_DOCUMENTATION,
    )
</file>

<file path="osducli/commands/storage/list.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Schema service get command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_STORAGE_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-k", "--kind", required=True, help="Get records by kind")
@handle_cli_exceptions
@command_with_output("results")
def _click_command(state: State, kind: str):
    """List records"""
    return list_records(state, kind)


def list_records(state: State, kind: str):
    """List records

    Args:
        state (State): Global state
        kind (str): Kind of records
    """
    connection = CliOsduClient(state.config)

    url = "query/records?kind=" + kind
    json = connection.cli_get_returning_json(CONFIG_STORAGE_URL, url)
    return json
</file>

<file path="osducli/commands/storage/versions.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Storage service versions command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_STORAGE_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-id", "--id", "_id", required=True, help="id to get versions for")
@handle_cli_exceptions
@command_with_output("versions")
def _click_command(state: State, _id: str):
    """List record versions"""
    return versions(state, _id)


def versions(state: State, id: str):  # pylint: disable=invalid-name,redefined-builtin
    """List record versions

    Args:
        state (State): Global state
        id (str): id to get versions for
    """
    connection = CliOsduClient(state.config)
    url = "records/versions/" + id
    json = connection.cli_get_returning_json(CONFIG_STORAGE_URL, url)
    return json
</file>

<file path="osducli/commands/unit/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Unit service commands"""
</file>

<file path="osducli/commands/unit/_const.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Unit constants"""

UNIT_SERVICE_NAME = "Unit service"
UNIT_STATUS_PATH = "../_ah/readiness_check"
UNIT_SWAGGER_PATH = "../swagger-ui.html"
</file>

<file path="osducli/commands/unit/info.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Unit info command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import handle_cli_exceptions
from osducli.commands.unit._const import (
    UNIT_SERVICE_NAME,
    UNIT_STATUS_PATH,
    UNIT_SWAGGER_PATH,
)
from osducli.config import CONFIG_UNIT_URL
from osducli.util.service_info import info


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State) -> dict:
    """Information about the service"""
    return info(state, UNIT_SERVICE_NAME, CONFIG_UNIT_URL, UNIT_STATUS_PATH, UNIT_SWAGGER_PATH)
</file>

<file path="osducli/commands/unit/list.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Unit service list command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_UNIT_URL


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output("units[].[displaySymbol,name,source]")
def _click_command(state: State):
    """List unit configuration"""
    return unit_list(state)


def unit_list(state: State):
    """List unit configuration

    Args:
        state (State): Global state
    """
    connection = CliOsduClient(state.config)
    json = connection.cli_get_returning_json(CONFIG_UNIT_URL, "unit?limit=10000")
    return json
</file>

<file path="osducli/commands/version/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Version information"""
</file>

<file path="osducli/commands/version/version.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Version command"""

import platform
import sys

import click
from packaging.version import Version
from requests.exceptions import RequestException

import osducli
from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import (
    CONFIG_CRS_CATALOG_URL,
    CONFIG_CRS_CONVERTER_URL,
    CONFIG_ENTITLEMENTS_URL,
    CONFIG_FILE_URL,
    CONFIG_LEGAL_URL,
    CONFIG_SCHEMA_URL,
    CONFIG_SEARCH_URL,
    CONFIG_STORAGE_URL,
    CONFIG_UNIT_URL,
    CONFIG_WORKFLOW_URL,
)
from osducli.log import get_logger
from osducli.util.pypi import get_pypi_version

logger = get_logger(__name__)


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output("results[]")
def _click_command(state: State):
    """Version information"""
    return version(state)


def get_runtime_version() -> str:
    """Get the runtime information.

    Returns:
        str: Runtime information
    """

    version_info = f"Python ({platform.system()}) {sys.version}"
    version_info += "\n\n"
    version_info += f"Python location '{sys.executable}'"
    return version_info


def get_api_info(connection: CliOsduClient, config_url_key: str, url_extra_path: str):
    """Check the status of the given service"""
    try:
        response = connection.cli_get_returning_json(config_url_key, url_extra_path)
        return response
    except RequestException:
        return None


def version(state: State):
    """Print version information to standard system out."""
    if state.is_user_friendly_mode():
        current_version = osducli.__VERSION__
        latest_version = get_pypi_version("osducli")
        version_info = f"Installed OSDU Cli Version {current_version}\n"
        if latest_version is not None:
            version_info += f"Latest OSDU Cli Version {latest_version}\n"
            if Version(current_version) < Version(latest_version):
                version_info += f"\b\n\033[33mWARNING: You are using osdu cli version {current_version}; however version {latest_version} is available.\033[39m"  # noqa: E501
                version_info += "\b\n\033[33mYou should consider upgrading via the 'pip install -U osducli' command\033[39m"  # noqa: E501
        else:
            version_info += "Latest OSDU Cli Version - unable to check!\n"

        version_info += "\n"
        version_info += get_runtime_version()
        print(version_info)

    services = [
        ("CRS catalog service", CONFIG_CRS_CATALOG_URL, "info"),
        ("CRS converter service", CONFIG_CRS_CONVERTER_URL, "info"),
        ("Entitlements service", CONFIG_ENTITLEMENTS_URL, "info"),
        ("File service", CONFIG_FILE_URL, "info"),
        ("Legal service", CONFIG_LEGAL_URL, "info"),
        ("Schema service", CONFIG_SCHEMA_URL, "info"),
        ("Search service", CONFIG_SEARCH_URL, "info"),
        ("Storage service", CONFIG_STORAGE_URL, "info"),
        ("Unit service", CONFIG_UNIT_URL, "info"),
        ("Workflow service", CONFIG_WORKFLOW_URL, "info"),
    ]
    results = []
    connection = CliOsduClient(state.config)
    for service in services:
        result = get_api_info(connection, service[1], service[2])
        results.append(result)
        if state.is_user_friendly_mode():
            print()
            print(service[0])
            print("  Version:", result["version"])
            print("  Build Time:", result["buildTime"])
            print("  Branch:", result["branch"])
            print("  Commit Id:", result["commitId"])

    return None if state.is_user_friendly_mode() else {"results": results}
</file>

<file path="osducli/commands/wellbore_ddms/well_log/data/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Wellbore DDMS Well Log data commands"""
</file>

<file path="osducli/commands/wellbore_ddms/well_log/data/add.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
"""Well Log add data command"""
import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.commands.wellbore_ddms._const import WELLBORE_DDMS_WELL_LOG_PATH


# click entry point
@click.command(cls=CustomClickCommand, help="Add Well Log data")
@click.option("-id", "--id", "_id", help="WellLog id to add data to", required=True)
@click.option("-f", "--file", "_file", help="WellLog data file to add", required=True)
@handle_cli_exceptions
@command_with_output("recordIds")
def _click_command(state: State, _id: str, _file: str):
    return add_data(state, _id, _file)


def add_data(state: State, identifier: str, data_file: str):
    """Well Log add data"""
    client = CliOsduClient(state.config)
    wellbore_client = client.get_wellbore_ddms_client(url_extra_path=WELLBORE_DDMS_WELL_LOG_PATH)

    with open(data_file, 'rb') as file:
        file_data = file.read()

    response = wellbore_client.create_well_log_data(identifier, file_data)
    client.check_status_code(response)
    return response.json()
</file>

<file path="osducli/commands/wellbore_ddms/well_log/data/get.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
"""Well Log get data command"""
import os

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.commands.wellbore_ddms._const import WELLBORE_DDMS_WELL_LOG_PATH


# click entry point
@click.command(cls=CustomClickCommand, help="Get Well Log data by id")
@click.option("-id", "--id", "_id", help="WellLog id to search for", required=True)
@click.option("-f", "--file", "_file", help="File to save WellLog data", required=True)
@handle_cli_exceptions
@command_with_output()
def _click_command(state: State, _id: str, _file: str):
    return get_data(state, _id, _file)


def get_data(state: State, identifier: str, out_file: str):
    """Get Well Log record by id"""
    client = CliOsduClient(state.config)
    wellbore_client = client.get_wellbore_ddms_client(url_extra_path=WELLBORE_DDMS_WELL_LOG_PATH)
    response = wellbore_client.get_well_log_data(identifier)
    client.check_status_code(response)

    with open(out_file, 'wb') as file:
        file.write(response.content)

    filename = os.path.abspath(file.name)
    print("File created: ", filename)
    return filename
</file>

<file path="osducli/commands/wellbore_ddms/well_log/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Wellbore DDMS Well Log commands"""
</file>

<file path="osducli/commands/wellbore_ddms/well_log/add.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
"""Well Log add record command"""
import json

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.commands.wellbore_ddms._const import WELLBORE_DDMS_WELL_LOG_PATH


# click entry point
@click.command(cls=CustomClickCommand, help="Add Well Log record")
@click.option("-f", "--file", "_file", help="WellLog record file to add", required=True)
@handle_cli_exceptions
@command_with_output("recordIds")
def _click_command(state: State, _file: str):
    return add_record(state, _file)


def add_record(state: State, record_file: str):
    """Add Well Log record"""
    client = CliOsduClient(state.config)
    wellbore_client = client.get_wellbore_ddms_client(url_extra_path=WELLBORE_DDMS_WELL_LOG_PATH)

    with open(record_file) as file:
        record_data = json.load(file)

    record_data_list = "[" + json.dumps(record_data) + "]"
    response = wellbore_client.create_well_log(record_data_list)
    client.check_status_code(response)
    return response.json()
</file>

<file path="osducli/commands/wellbore_ddms/well_log/get.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
"""Well Log get record command"""
import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.commands.wellbore_ddms._const import WELLBORE_DDMS_WELL_LOG_PATH


# click entry point
@click.command(cls=CustomClickCommand, help="Get Well Log record by id")
@click.option("-id", "--id", "_id", help="WellLog id to search for", required=True)
@handle_cli_exceptions
@command_with_output()
def _click_command(state: State, _id: str):
    return get_record(state, _id)


def get_record(state: State, identifier: str):
    """Get Well Log record by id"""
    client = CliOsduClient(state.config)
    wellbore_client = client.get_wellbore_ddms_client(url_extra_path=WELLBORE_DDMS_WELL_LOG_PATH)
    response = wellbore_client.get_well_log(identifier)
    client.check_status_code(response)
    return response.json()
</file>

<file path="osducli/commands/wellbore_ddms/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Wellbore DDMS commands"""
</file>

<file path="osducli/commands/wellbore_ddms/_const.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Wellbore DDMS constants"""

WELLBORE_DDMS_SERVICE_NAME = "Wellbore DDMS service"
WELLBORE_DDMS_STATUS_PATH = "/about"
WELLBORE_DDMS_SWAGGER_PATH = "https://community.opengroup.org/osdu/platform/domain-data-mgmt-services/wellbore/wellbore-domain-services/-/blob/master/spec/generated/openapi.json"  # noqa: E501
WELLBORE_DDMS_DOCUMENTATION = "https://community.opengroup.org/osdu/platform/domain-data-mgmt-services/wellbore/wellbore-domain-services/-/tree/master"  # noqa: E501
WELLBORE_DDMS_WELL_LOG_PATH = "/ddms/v3/welllogs"
</file>

<file path="osducli/commands/wellbore_ddms/info.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Wellbore DDMS info command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import handle_cli_exceptions
from osducli.commands.wellbore_ddms._const import (
    WELLBORE_DDMS_DOCUMENTATION,
    WELLBORE_DDMS_SERVICE_NAME,
    WELLBORE_DDMS_STATUS_PATH,
    WELLBORE_DDMS_SWAGGER_PATH,
)
from osducli.config import CONFIG_WELLBORE_DDMS_URL
from osducli.util.service_info import info


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State) -> dict:
    """Information about the service"""
    return info(
        state,
        WELLBORE_DDMS_SERVICE_NAME,
        CONFIG_WELLBORE_DDMS_URL,
        WELLBORE_DDMS_STATUS_PATH,
        WELLBORE_DDMS_SWAGGER_PATH,
        WELLBORE_DDMS_DOCUMENTATION,
    )
</file>

<file path="osducli/commands/workflow/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Workflow service commands"""
</file>

<file path="osducli/commands/workflow/_const.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Workflow constants"""

WORKFLOW_SERVICE_NAME = "Workflow service"
WORKFLOW_STATUS_PATH = "../readiness_check"
WORKFLOW_SWAGGER_PATH = None
</file>

<file path="osducli/commands/workflow/get.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Workflow get command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_WORKFLOW_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-n", "--name", help="Workflow (DAG) name", required=True)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State, name: str) -> dict:
    """Get information about a workflow"""
    return get_workflow(state, name)


def get_workflow(state: State, name: str) -> dict:
    """Get a workflows

    Args:
        state (State): Global state
        name (str): Workflow name

    Returns:
        dict: Response from service
    """
    connection = CliOsduClient(state.config)
    url = "workflow/" + name
    response_json = connection.cli_get_returning_json(CONFIG_WORKFLOW_URL, url)
    return response_json
</file>

<file path="osducli/commands/workflow/info.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Workflow info command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import handle_cli_exceptions
from osducli.commands.workflow._const import (
    WORKFLOW_SERVICE_NAME,
    WORKFLOW_STATUS_PATH,
    WORKFLOW_SWAGGER_PATH,
)
from osducli.config import CONFIG_WORKFLOW_URL
from osducli.util.service_info import info


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State) -> dict:
    """Information about the service"""
    return info(
        state,
        WORKFLOW_SERVICE_NAME,
        CONFIG_WORKFLOW_URL,
        WORKFLOW_STATUS_PATH,
        WORKFLOW_SWAGGER_PATH,
    )
</file>

<file path="osducli/commands/workflow/list.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Workflow list command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_WORKFLOW_URL


# click entry point
@click.command(cls=CustomClickCommand)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State) -> dict:
    """List available workflows"""
    return list_workflows(state)


def list_workflows(state: State) -> dict:
    """List available workflows

    Args:
        state (State): Global state

    Returns:
        dict: Response from service
    """
    connection = CliOsduClient(state.config)
    response_json = connection.cli_get_returning_json(CONFIG_WORKFLOW_URL, "workflow?prefix=")
    return response_json
</file>

<file path="osducli/commands/workflow/register.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Workflow list command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_WORKFLOW_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-n", "--name", help="Workflow (DAG) name", required=True)
@click.option("-d", "--description", help="Description", required=True)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State, name: str, description: str) -> dict:
    """Register an Airflow workflow with OSDU"""
    return register_workflow(state, name, description)


def register_workflow(state: State, name: str, description: str) -> dict:
    """Register an Airflow workflow with OSDU

    Args:
        state (State): Global state
        name (str): DAG Name
        description (str): Description

    Returns:
        dict: Response from service
    """
    connection = CliOsduClient(state.config)

    request = {
        "description": description,
        "registrationInstructions": {},
        "workflowName": name,
    }
    response_json = connection.cli_post_returning_json(CONFIG_WORKFLOW_URL, "workflow", request)
    return response_json
</file>

<file path="osducli/commands/workflow/runs.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Workflow runs command"""

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_WORKFLOW_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-n", "--name", help="Workflow (DAG) name", required=True)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State, name: str) -> dict:
    """Get runs of a workflow"""
    return runs(state, name)


def runs(state: State, name: str) -> dict:
    """Get runs

    Args:
        state (State): Global state
        name (str): Workflow (DAG) name

    Returns:
        dict: Response from service
    """
    connection = CliOsduClient(state.config)
    url = f"workflow/{name}/workflowRun"
    response_json = connection.cli_get_returning_json(CONFIG_WORKFLOW_URL, url)
    return response_json
</file>

<file path="osducli/commands/workflow/status.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Dataload status command"""

import sys
import time

import click

from osducli.click_cli import CustomClickCommand, State, command_with_output
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_WORKFLOW_URL, CLIConfig
from osducli.log import get_logger

# pylint: disable=duplicate-code

START_TIME = "startTimeStamp"
END_TIME = "endTimeStamp"
STATUS = "status"
RUN_ID = "runId"
TIME_TAKEN = "timeTaken"
FINISHED = "finished"
FAILED = "failed"

logger = get_logger(__name__)


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-r", "--runid", help="Runid to query status of.")
@click.option(
    "-rl",
    "--runid-log",
    help="Path to a file containing run ids to get status of (see dataload ingest -h).",
    type=click.Path(exists=True, file_okay=True, readable=True, resolve_path=True),
)
@click.option(
    "-w", "--wait", help="Whether to wait for runs to complete.", is_flag=True, show_default=True
)
@handle_cli_exceptions
@command_with_output(None)
def _click_command(state: State, runid: str = None, runid_log: str = None, wait: bool = False):
    """Get status of workflow runs."""
    return status(state, runid, runid_log, wait)


def status(state: State, runid: str = None, runid_log: str = None, wait: bool = False) -> dict:
    """Get status of workflow runs

    Args:
        state (State): Global state
        runid (str): [description]
        runid_log (str): [description]
        wait (bool): [description]

    Returns:
        dict: Response from service
    """
    runids = []
    if runid is not None:
        runids = [runid]
    elif runid_log is not None:
        with open(runid_log, encoding="utf-8") as handle:
            runids = [run_id.rstrip() for run_id in handle]
    else:
        logger.error("Specify either runid or runid-log")
        sys.exit(1)

    return check_status(state.config, runids, wait)


def check_status(config: CLIConfig, runids: list, wait: bool) -> list:
    """Check statis for a list of runids

    Args:
        config (CLIConfig): configuration
        runids (list): list of runids
        wait (bool): whether to wait for status to change out of running

    Returns:
        list: list containing runid and status.
    """
    results = _check_status(config, runids)

    if wait:
        # parse the results to see if the ingestion is complete.
        while True:
            ingestion_complete = True
            for result in results:
                if result.get("status") == "running":
                    ingestion_complete = False
                    logger.debug(
                        "Not all records finished. Checking again in 30s. Tried upto %s and"
                        " found running",
                        result.get("runId"),
                    )
                    break

            if ingestion_complete:
                break

            print(results)
            time.sleep(30)  # 30 seconds sleep.
            results = _check_status(config, runids)  # recheck the status.

    return results


def _check_status(config: CLIConfig, run_id_list: list):
    logger.debug("list of run-ids: %s", run_id_list)

    results = []
    for run_id in run_id_list:
        connection = CliOsduClient(config)
        response_json = connection.cli_get_returning_json(
            CONFIG_WORKFLOW_URL, "workflow/Osdu_ingest/workflowRun/" + run_id
        )
        if response_json is not None:
            run_status = response_json.get(STATUS)
            if run_status == "running":
                results.append({RUN_ID: run_id, STATUS: run_status})
            else:
                time_taken = 0
                if END_TIME in response_json:
                    time_taken = response_json.get(END_TIME) - response_json.get(START_TIME)
                results.append(
                    {
                        RUN_ID: run_id,
                        END_TIME: response_json.get(END_TIME),
                        START_TIME: response_json.get(START_TIME),
                        STATUS: run_status,
                        TIME_TAKEN: time_taken / 1000,
                    }
                )
        else:
            results.append({RUN_ID: run_id, STATUS: "Unable To fetch status"})
    return results
</file>

<file path="osducli/commands/workflow/unregister.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Workflow list command"""

import click

from osducli.click_cli import CustomClickCommand, State, global_params
from osducli.cliclient import CliOsduClient, handle_cli_exceptions
from osducli.config import CONFIG_WORKFLOW_URL


# click entry point
@click.command(cls=CustomClickCommand)
@click.option("-n", "--name", help="Workflow (DAG) name", required=True)
@handle_cli_exceptions
@global_params
def _click_command(state: State, name: str) -> dict:
    """Un-register an Airflow workflow from OSDU"""
    return unregister_workflow(state, name)


def unregister_workflow(state: State, name: str) -> dict:
    """Un-register an Airflow workflow from OSDU

    Args:
        state (State): Global state
        name (str): DAG Name
    """
    connection = CliOsduClient(state.config)
    connection.cli_delete(CONFIG_WORKFLOW_URL, "workflow/" + name, [204])
</file>

<file path="osducli/commands/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
</file>

<file path="osducli/util/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
</file>

<file path="osducli/util/exceptions.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


class CliError(Exception):
    """General Cli Exception.

    Attributes:
        message -- explanation of the error
    """

    def __init__(self, message: str):
        self.message = message
        super().__init__(self.message)
</file>

<file path="osducli/util/file.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import errno
import glob
import os


def get_files_from_path(path: str) -> list:
    """Given a path get a list of all files.

    Args:
        path (str): path

    Returns:
        list: list of file paths
    """
    allfiles = []
    if os.path.isfile(path):
        allfiles = [path]

    # Recursive traversal of files and subdirectories of the root directory and files processing
    for root, _, files in os.walk(path):
        for file in files:
            allfiles.append(os.path.join(root, file))
    return allfiles


def get_files_from_path_with_suffix(path: str, suffix: str) -> list:
    """Given a path get a list of all files with a certain suffix.

    Args:
        path (str): path
        suffix (str): file suffix to filter by

    Returns:
        list: list of file paths
    """
    if os.path.isfile(path):
        return [path] if path.endswith(suffix) else []

    pattern = os.path.join(path, '**', f'*{suffix}')
    return glob.glob(pattern, recursive=True)


def ensure_directory_exists(directory: str):
    """Create a directory if it doesn't exist"""
    if not os.path.isdir(directory):
        try:
            os.makedirs(directory)
        except OSError as _e:
            if _e.errno != errno.EEXIST:
                raise _e
</file>

<file path="osducli/util/prompt.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Read and modify configuration settings related to the CLI"""

import getpass
import sys

from osducli.log import get_logger

logger = get_logger(__name__)

_INVALID_PASSWORD_MSG = "Passwords do not match."


class NoTTYException(Exception):
    """Exception if no interactive console available

    Args:
        Exception ([type]): [description]
    """


def _input(msg: str) -> str:
    """[summary]

    Args:
        msg (str): [description]

    Returns:
        str: [description]
    """
    result = input(msg)  # pylint: disable=bad-builtin
    return result


def verify_is_a_tty():
    """[summary]

    Raises:
        NoTTYException: [description]
    """
    if not sys.stdin.isatty():
        logger.debug("No tty available.")
        raise NoTTYException()


def prompt(
    msg: str, default: str = None, default_value_display_length: int = None, help_string: str = None
) -> str:
    """Prompt the user for input with support for default value and help

    If the msg string contains []: and default is specified then the msg string is
    expanded to indlude default.

    If the user input is '?' then help text is displayed if specified.

    Args:
        msg (str): Message to display to the user
        default (str): Default value if nothing entered
        default_value_display_length (int): Max length for displayed default text
        help_string (str, optional): Help string shown if the user enters ?. Defaults to None.

    Returns:
        str: [description]
    """
    verify_is_a_tty()

    if default is not None:
        displayed_default = default
        if default_value_display_length and len(default) > default_value_display_length:
            displayed_default = (
                displayed_default[0 : default_value_display_length - 2] + ".."  # noqa: E203
            )

        msg = msg.replace("[]:", f"[{displayed_default}]:")

    while True:
        val = _input(msg)
        if val == "?" and help_string is not None:
            print(help_string)
            continue
        if val == "" and default is not None:
            return default

        return val


def prompt_int(msg: str, help_string: str = None) -> int:
    """[summary]

    Args:
        msg (str): [description]
        help_string (str, optional): [description]. Defaults to None.

    Returns:
        int: [description]
    """
    verify_is_a_tty()

    while True:
        value = _input(msg)
        if value == "?" and help_string is not None:
            print(help_string)
            continue
        try:
            return int(value)
        except ValueError:
            logger.warning("%s is not a valid number", value)


def prompt_pass(msg: str = "Password: ", confirm: bool = False, help_string: str = None):
    """[summary]

    Args:
        msg (str, optional): [description]. Defaults to 'Password: '.
        confirm (bool, optional): [description]. Defaults to False.
        help_string (str, optional): [description]. Defaults to None.

    Returns:
        [type]: [description]
    """
    verify_is_a_tty()
    while True:
        password = getpass.getpass(msg)
        if password == "?" and help_string is not None:
            print(help_string)
            continue
        if confirm:
            password2 = getpass.getpass("Confirm " + msg)
            if password != password2:
                logger.warning(_INVALID_PASSWORD_MSG)
                continue
        return password


def prompt_y_n(msg: str, default: str = None, help_string: str = None):
    """[summary]

    Args:
        msg (str): [description]
        default (bool, optional): [description]. Defaults to None.
        help_string (str, optional): [description]. Defaults to None.

    Returns:
        [type]: [description]
    """
    return _prompt_bool(msg, "y", "n", default=default, help_string=help_string)


def prompt_t_f(msg: str, default: str = None, help_string: str = None):
    """[summary]

    Args:
        msg (str): [description]
        default (str, optional): [description]. Defaults to None.
        help_string (str, optional): [description]. Defaults to None.

    Returns:
        [type]: [description]
    """
    return _prompt_bool(msg, "t", "f", default=default, help_string=help_string)


def _prompt_bool(
    msg: str, true_str: str, false_str: str, default: str = None, help_string: str = None
):
    """[summary]

    Args:
        msg (str): [description]
        true_str (str): [description]
        false_str (str): [description]
        default (str, optional): [description]. Defaults to None.
        help_string (str, optional): [description]. Defaults to None.

    Raises:
        ValueError: [description]

    Returns:
        [type]: [description]
    """
    verify_is_a_tty()
    if default not in [None, true_str, false_str]:
        raise ValueError(f"Valid values for default are {true_str}, {false_str} or None")
    _yes = true_str.upper() if default == true_str else true_str
    _no = false_str.upper() if default == false_str else false_str
    while True:
        ans = _input(f"{msg} ({_yes}/{_no}): ")
        if ans == "?" and help_string is not None:
            print(help_string)
            continue
        if ans.lower() == _no.lower():
            return False
        if ans.lower() == _yes.lower():
            return True
        if default and not ans:
            return default == _yes.lower()


def prompt_choice_list(msg, a_list, default=1, help_string=None):
    """Prompt user to select from a list of possible choices.

    Args:
        msg (str): A message displayed to the user before the choice list
        a_list (list): The list of choices (list of strings or list of dicts with 'name' & 'desc')
        default (int): The default option that should be chosen if user doesn't enter a choice
        help_string (str): Help string to display

    Returns:
        The list index of the item chosen.
    """
    verify_is_a_tty()
    options = "\n".join(
        [
            # pylint: disable=consider-using-f-string
            " [{}] {}{}".format(
                i + 1,
                x["name"] if isinstance(x, dict) and "name" in x else x,
                " - " + x["desc"] if isinstance(x, dict) and "desc" in x else "",
            )
            for i, x in enumerate(a_list)
        ]
    )
    allowed_vals = list(range(1, len(a_list) + 1))
    while True:
        val = _input(f"{msg}\n{options}\nPlease enter a choice [Default choice({default})]: ")
        if val == "?" and help_string is not None:
            print(help_string)
            continue
        if not val:
            val = f"{default}"
        try:
            ans = int(val)
            if ans in allowed_vals:
                # array index is 0-based, user input is 1-based
                return ans - 1
            raise ValueError
        except ValueError:
            logger.warning("Valid values are %s", allowed_vals)
</file>

<file path="osducli/util/pypi.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import requests

from osducli.log import get_logger

logger = get_logger(__name__)


def get_pypi_version(package: str) -> str:
    """Get the latest version of a package from pypi

    Args:
        package (str): Package name

    Returns:
        str: Version number or None if unable to retrieve.
    """
    try:
        response = requests.get(f"https://pypi.org/pypi/{package}/json", timeout=20)
        if response.status_code == 200:
            data = response.json()
            return data["info"]["version"]
    except Exception as ex:  # pylint: disable=broad-except
        logger.debug(ex, exc_info=True)

    return None
</file>

<file path="osducli/util/service_info.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Service information"""

from osducli.click_cli import State
from osducli.cliclient import CliOsduClient
from osducli.commands.status.status import check_status
from osducli.commands.version.version import get_api_info


def info(
    state: State,
    name: str,
    config_url_key: str,
    status_path: str,
    swagger_path: str,
    documentation: str = None,
) -> dict:
    """Return information about the service

    Args:
        state (State): Global state
        name (str): Name of the service
        config_url_key (str): Config url key
        status_path (str): Path to status service
        swagger_path (str): Swagger path
        documentation (str): Link to documentaion about the underlying service

    Returns:
        dict: Response from service
    """
    connection = CliOsduClient(state.config)

    status = check_status(connection, name, config_url_key, status_path)
    if state.is_user_friendly_mode():
        print("Status:", status["status"])
        print("Reason:", status["reason"])

    version = get_api_info(connection, config_url_key, "info")

    swagger_path_expanded = (
        connection.url_from_config(config_url_key, swagger_path) if swagger_path else None
    )

    if state.is_user_friendly_mode():
        if version:
            print("Version:", version["version"])
            print("Build Time:", version["buildTime"])
            print("Branch:", version["branch"])
            print("Commit Id:", version["commitId"])
        else:
            print("No version information available")

        if swagger_path_expanded:
            print("Swagger:", swagger_path_expanded)
        else:
            print("Swagger path unknown")

        if documentation:
            print("Documentation:", documentation)

    return (
        None
        if state.is_user_friendly_mode()
        else {
            "status": status,
            "version": version,
            "swagger": swagger_path_expanded,
            "documentation": documentation,
        }
    )
</file>

<file path="osducli/__init__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

""" OSDU command line environment"""

__VERSION__ = "0.0.45"
</file>

<file path="osducli/__main__.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Entry or launch point for CLI."""

import importlib
import os.path
import pkgutil

import click

from osducli.click_cli import CustomClickGroup, CustomMainClickGroup, State


def get_commands_from_pkg(pkg) -> dict:
    """Dynamically and recursively get all click commands within the specified package

    Args:
        pkg ([type]): [description]

    Returns:
        dict: [description]
    """
    # groups with only 1 command that should be kept as groups for future expandability
    keep_groups = [
        "osducli.commands.legal",
        "osducli.commands.list",
        "osducli.commands.unit",
    ]
    pkg_obj = importlib.import_module(pkg)

    pkg_path = os.path.dirname(pkg_obj.__file__)
    commands = {}
    for module in pkgutil.iter_modules([pkg_path]):
        module_obj = importlib.import_module(f"{pkg}.{module.name}")

        if not module.ispkg:
            if hasattr(module_obj, "_click_command"):
                commands[module.name] = module_obj._click_command
                # print(f"Add command {pkg}.{module.name}")

        else:
            group_commands = get_commands_from_pkg(f"{pkg}.{module.name}")
            if len(group_commands) == 1 and f"{pkg}.{module.name}" not in keep_groups:
                # print(f"Add command {pkg}.{module.name} - {module.name.replace('_', '-')}")
                click_command = list(group_commands.values())[0]
                click_command.context_settings["help_option_names"] = ["-h", "--help"]
                commands[module.name.replace("_", "-")] = click_command
            elif len(group_commands) >= 1:
                # print(f"Add group {module.name.replace('_', '-')}\n{group_commands}")
                commands[module.name.replace("_", "-")] = CustomClickGroup(
                    context_settings={"help_option_names": ["-h", "--help"]},
                    help=module_obj.__doc__,
                    commands=group_commands,
                )
            # else:
            #     print(f"Skip group {module.name.replace('_', '-')}")

    return commands


# Main entry point for OSDU CLI.
# noqa: W606,W605
@click.group(
    cls=CustomMainClickGroup,
    commands=get_commands_from_pkg("osducli.commands"),
    context_settings={"help_option_names": ["-h", "--help"]},
)
@click.pass_context
def cli(ctx):
    """
    \b
      ___   ____   ____   _   _     ____  _      ___
     / _ \\ / ___| |  _ \\ | | | |   / ___|| |    |_ _|
    | | | |\\___ \\ | | | || | | |  | |    | |     | |
    | |_| | ___) || |_| || |_| |  | |___ | |___  | |
     \\___/ |____/ |____/  \\___/    \\____||_____||___|
    Welcome to the OSDU CLI!

    \033[33mNote: This is currently a work in progress and may contain bugs or breaking changes.
    Please share ideas / issues on the git page:
    \b

    https://community.opengroup.org/osdu/platform/data-flow/data-loading/osdu-cli/-/issues\033[39m

    Use `osdu version` to display the current version.

    Usage:
    osdu [command]
    """
    ctx.obj = State()


def main():
    """Main entry point for OSDU CLI."""
    cli(None)


if __name__ == "__main__":
    main()
</file>

<file path="osducli/click_cli.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Entry or launch point for CLI.

Handles creating and launching a CLI to handle a user command."""

import collections
import functools
import json
import logging
from os import path
from pathlib import Path

import click
from click.core import Context
from click.formatting import HelpFormatter
from jmespath import Options
from jmespath import compile as compile_jmespath
from packaging.version import Version
from tabulate import tabulate

import osducli
from osducli.config import CLI_ENV_VAR_PREFIX, CLIConfig
from osducli.log import get_logger
from osducli.state import get_default_config, get_default_config_path
from osducli.util.pypi import get_pypi_version


class State:
    """Global state passed to all click commands"""

    def __init__(self):
        self.debug = False
        self.config_path = None
        self.config = None
        self.output = None
        self.jmes = None

    def __repr__(self):
        return f"State=Debug: {self.debug}, Config path: {self.config_path}"

    def is_user_friendly_mode(self) -> bool:
        """Return whether we are running in a user friendly output mode

        Returns:
            bool: whether running in user friendly mode
        """
        return self.output is None


def _format_click_options(cmd: click.Command, ctx: Context, formatter: HelpFormatter) -> None:
    """Writes options into the formatter split between Options and Common Options."""
    opts = []
    common_opts = []
    for param in cmd.get_params(ctx):
        _rv = param.get_help_record(ctx)
        if _rv is not None:
            if param.name in {"help", "debug", "config", "output", "filter"}:
                common_opts.append(_rv)
            else:
                opts.append(_rv)

    if opts:
        with formatter.section("Options"):
            formatter.write_dl(opts)

    if common_opts:
        with formatter.section("Common Options"):
            formatter.write_dl(common_opts)


class CustomClickGroup(click.Group):
    """Custom click.Group class providing customised help text"""

    def format_options(self, ctx: Context, formatter: HelpFormatter) -> None:
        _format_click_options(self, ctx, formatter)
        self.format_commands(ctx, formatter)


class CustomMainClickGroup(CustomClickGroup):
    """Custom click.Group class providing customised help text"""

    def format_help(self, ctx: Context, formatter: HelpFormatter) -> None:
        """Writes the help into the formatter if it exists.

        This is a low-level method called by :meth:`get_help`.

        This calls the following methods:

        -   :meth:`format_usage`
        -   :meth:`format_help_text`
        -   :meth:`format_options`
        -   :meth:`format_epilog`
        """
        super().format_help(ctx, formatter)
        current_version = osducli.__VERSION__
        latest_version = get_pypi_version("osducli")
        if latest_version is not None and Version(current_version) < Version(latest_version):
            formatter.write_paragraph()
            formatter.write_text(
                f"\b\n\033[33mWARNING: You are using osdu cli version {current_version}; however version {latest_version} is available.\033[39m"  # noqa: E501
            )
            formatter.write_text(
                "\b\n\033[33mYou should consider upgrading via the 'pip install -U osducli' command\033[39m"
            )


class CustomClickCommand(click.Command):
    """Custom click.GrouCommand class providing customised help text"""

    def format_options(self, ctx: Context, formatter: HelpFormatter) -> None:
        _format_click_options(self, ctx, formatter)


def global_params(func):
    """Handle global parameters setting to setup state and remove parameters from those passed
    to the decorated function call."""

    def debug_callback(ctx, _, value):
        state = ctx.ensure_object(State)
        state.debug = value
        logging.basicConfig()
        root_logger = logging.getLogger()
        root_logger.setLevel(logging.INFO)
        if value:
            root_logger = logging.getLogger()
            root_logger.setLevel(logging.DEBUG)
            logger = get_logger(__name__)
            # logger.setLevel(logging.DEBUG)
            # requests_log = logging.getLogger("urllib3")
            # requests_log.setLevel(logging.DEBUG)
            # requests_log.propagate = True
            logger.debug("Debugging enabled")
        return value

    def config_callback(ctx, _, value):
        state = ctx.ensure_object(State)
        state.config_path = value
        if value:
            if Path(value).is_file():
                config_path, config_file = path.split(value)
                state.config = CLIConfig(config_path, CLI_ENV_VAR_PREFIX, config_file)
            else:
                config_path = path.split(get_default_config_path(locate=True))[0]
                state.config = CLIConfig(config_path, CLI_ENV_VAR_PREFIX, value)
        else:
            state.config = get_default_config(True)
        return value

    pass_state = click.make_pass_decorator(State)

    @click.option(
        "--debug/--no-debug",
        default=False,
        envvar="REPO_DEBUG",
        help="Increase logging verbosity to show all debug logs.",
        callback=debug_callback,
    )
    @click.option(
        "-c",
        "--config",
        envvar="OSDU_CONFIG",
        help=(
            "Path to a configuration file. You can configure the default file using 'osducli config"
            " default'."
        ),
        type=click.Path(readable=True),
        callback=config_callback,
    )
    @functools.wraps(func)
    @pass_state
    def wrapper(*args, **kwargs):
        kwargs.pop("debug")
        kwargs.pop("config")
        return func(*args, **kwargs)

    return wrapper


def command_with_output(table_transformer=None):
    """Handle global parameters setting to setup state and remove parameters from those passed
    to the decorated function call."""

    def wrapper_for_params(func):
        def output_callback(ctx, _, value):
            state = ctx.ensure_object(State)
            state.output = value
            return value

        def jmes_callback(ctx, _, value):
            state = ctx.ensure_object(State)
            state.jmes = value
            return value

        @click.option(
            "-o",
            "--output",
            envvar="OSDU_CONFIG",
            type=click.Choice(["json"], case_sensitive=False),
            help="Output format (default is a user friendly table format).",
            callback=output_callback,
        )
        @click.option(
            "--filter",
            help=(
                "JMESPath string for filtering output. See http://jmespath.org/ for more"
                " information and examples."
            ),
            callback=jmes_callback,
        )
        @functools.wraps(func)
        @global_params
        def func_wrapper(*args, **kwargs):
            state = args[0]
            kwargs.pop("output")
            kwargs.pop("filter")
            result = func(*args, **kwargs)
            if result is not None:
                if type(result) in [dict, list]:
                    if state.jmes is not None or (
                        table_transformer is not None and state.output is None
                    ):
                        jmes = state.jmes if state.jmes is not None else table_transformer
                        try:
                            query_expression = compile_jmespath(jmes)
                            result = query_expression.search(
                                result, Options(collections.OrderedDict)
                            )
                        except KeyError as ex:
                            # Raise a ValueError which argparse can handle
                            raise ValueError from ex

                    if state.output == "json":
                        print(json.dumps(result, indent=2))
                    else:
                        result_list = result if isinstance(result, list) else [result]
                        # should_sort_keys = not state.jmes
                        table_output = _TableOutput(False)  # should_sort_keys)
                        print(table_output.dump(result_list))

        return func_wrapper

    return wrapper_for_params


class _TableOutput:  # pylint: disable=too-few-public-methods
    SKIP_KEYS = []

    def __init__(self, should_sort_keys=False):
        self.should_sort_keys = should_sort_keys

    @staticmethod
    def _capitalize_first_char(text: str):
        return text[0].upper() + text[1:] if text else text

    def _auto_table_item(self, item):
        new_entry = collections.OrderedDict()
        try:
            keys = sorted(item) if self.should_sort_keys and isinstance(item, dict) else item.keys()
            for k in keys:
                if k in _TableOutput.SKIP_KEYS:
                    continue
                if item[k] is not None and not isinstance(item[k], list | dict | set):
                    new_entry[_TableOutput._capitalize_first_char(k)] = item[k]
        except AttributeError:
            # handles odd cases where a string/bool/etc. is returned
            if isinstance(item, list):
                for col, val in enumerate(item):
                    new_entry[f"Column{col + 1}"] = val
            else:
                new_entry["Result"] = item
        return new_entry

    def _auto_table(self, result):
        if isinstance(result, list):
            new_result = []
            for item in result:
                new_result.append(self._auto_table_item(item))
            return new_result
        return self._auto_table_item(result)

    def dump(self, data):
        """Dump table data to a tabulated string

        Args:
            data ([type]): [description]

        Raises:
            ValueError: [description]

        Returns:
            [type]: [description]
        """

        table_data = self._auto_table(data)
        table_str = (
            tabulate(table_data, headers="keys", tablefmt="simple", disable_numparse=True)
            if table_data
            else ""
        )
        if table_str == "\n":
            raise ValueError("Unable to extract fields for table.")
        return table_str + "\n"
</file>

<file path="osducli/cliclient.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
"""Useful functions."""

import json
import sys
from configparser import NoOptionError, NoSectionError
from functools import wraps
from urllib.parse import urljoin

import requests
from osdu_api.auth.refresh_token import BaseTokenRefresher
from osdu_api.clients.base_client import BaseClient
from osdu_api.clients.entitlements.entitlements_client import EntitlementsClient
from osdu_api.clients.search.search_client import SearchClient
from osdu_api.clients.storage.record_client import RecordClient
from osdu_api.model.http_method import HttpMethod
from osdu_api.providers.constants import (
    AWS_CLOUD_PROVIDER,
    AZURE_CLOUD_PROVIDER,
    BAREMETAL_PROVIDER,
    GOOGLE_CLOUD_PROVIDER,
    IBM_CLOUD_PROVIDER,
)
from osdu_api.providers.credentials import get_credentials
from requests.models import HTTPError

from osducli.auth.credentials import (
    aws_token_credentials,
    msal_interactive_credentials,
    msal_non_interactive_credentials,
    refresh_token_credentials,
)
from osducli.config import (
    CONFIG_AUTHENTICATION_MODE,
    CONFIG_DATA_PARTITION_ID,
    CONFIG_ENTITLEMENTS_URL,
    CONFIG_SEARCH_URL,
    CONFIG_SERVER,
    CONFIG_STORAGE_URL,
    CONFIG_WELLBORE_DDMS_URL,
    CLIConfig,
)
from osducli.log import get_logger
from osducli.util.exceptions import CliError
from osducli.wbddms_client import WellboreDdmsClient

MSG_JSON_DECODE_ERROR = (
    "Unable to decode the response. Try running again with the --debug command line argument for"
    " more information"
)
MSG_HTTP_ERROR = (
    "An error occurred when accessing the api. Try running again with the --debug command line"
    " argument for more information"
)


logger = get_logger(__name__)


def handle_cli_exceptions(function):
    """Decorator to provide common cli error handling"""

    @wraps(function)
    def decorated(*args, **kwargs):
        try:
            return function(*args, **kwargs)
        except HTTPError as ex:
            logger.error(MSG_HTTP_ERROR)
            logger.error("Error (%s) - %s", ex.response.status_code, ex.response.reason)
            try:
                error_content = ex.response.json()
                logger.error("Message: %s", error_content.get("message"))
            except json.JSONDecodeError:
                logger.error("Response: %s", ex.response.content)
        except CliError as ex:
            logger.error("Error %s", ex.message)
        except ValueError as ex:
            logger.error(MSG_JSON_DECODE_ERROR)
            logger.error(ex)
        except (NoOptionError, NoSectionError) as ex:
            logger.warning(
                "Configuration missing from config ('%s'). Run 'osdu config update'", ex.args[0]
            )
        sys.exit(1)

    return decorated


class CliOsduClient(BaseClient):
    """Specific class for use from the CLI that provides common error handling, use of configuration
    and messaging

    Args:
        OsduClient ([type]): [description]
    """

    def __init__(self, config: CLIConfig):
        """Setup the new client

        Args:
            config (CLIConfig): cli configuration
        """

        self.config = config

        try:
            # required
            self.server_url = config.get("core", CONFIG_SERVER)
            data_partition = config.get("core", CONFIG_DATA_PARTITION_ID)
            authentication_mode = config.get("core", CONFIG_AUTHENTICATION_MODE)

            if authentication_mode == "refresh_token":
                credentials = refresh_token_credentials(config)
            elif authentication_mode == "msal_interactive":
                credentials = msal_interactive_credentials(config)
            elif authentication_mode == "msal_non_interactive":
                credentials = msal_non_interactive_credentials(config)
            elif authentication_mode == AWS_CLOUD_PROVIDER:
                credentials = aws_token_credentials(config)
            elif authentication_mode in [
                AZURE_CLOUD_PROVIDER,
                BAREMETAL_PROVIDER,
                GOOGLE_CLOUD_PROVIDER,
                IBM_CLOUD_PROVIDER,
            ]:
                credentials = get_credentials(authentication_mode)
            else:
                logger.error(
                    "Unknown type of authentication mode %s. Run 'osdu config update'.",
                    authentication_mode,
                )
                sys.exit(2)

            token_refresher = BaseTokenRefresher(credentials)
            super().__init__(config_manager=config, data_partition_id=data_partition, token_refresher=token_refresher)
        except (NoOptionError, NoSectionError) as ex:
            logger.warning(
                "Authentication information missing from config ('%s'). Run 'osdu config update'",
                ex.args[0],
            )
            sys.exit(1)

    def url_from_config(self, config_url_key: str, url_extra_path: str) -> str:
        """Construct a url using values from configuration"""
        unit_url = self.config.get("core", config_url_key)
        url = urljoin(self.server_url, unit_url) + url_extra_path
        return url

    def check_status_code(self, response: requests.Response, ok_status_codes: list = None):
        """Check the status code of the response and raise an exception if not in the list of ok status codes"""
        if ok_status_codes is None:
            ok_status_codes = [200]
        if response.status_code not in ok_status_codes:
            raise HTTPError(response=response)

    def get_search_client(self) -> SearchClient:
        """Get a client for the search service"""
        search_url = self.url_from_config(CONFIG_SEARCH_URL, "")
        if search_url.endswith("/"):
            search_url = search_url[:-1]
        return SearchClient(
            search_url=search_url,
            config_manager=self.config,
            data_partition_id=self.data_partition_id,
            token_refresher=self.token_refresher
        )

    def get_storage_record_client(self) -> RecordClient:
        """Get a client for the storage record service"""
        storage_url = self.url_from_config(CONFIG_STORAGE_URL, "")
        if storage_url.endswith("/"):
            storage_url = storage_url[:-1]
        return RecordClient(
            storage_url=storage_url,
            config_manager=self.config,
            data_partition_id=self.data_partition_id,
            token_refresher=self.token_refresher
        )

    def get_entitlements_client(self) -> EntitlementsClient:
        """Get a client for the entitlements service"""
        entitlements_url = self.url_from_config(CONFIG_ENTITLEMENTS_URL, "")
        if entitlements_url.endswith("/"):
            entitlements_url = entitlements_url[:-1]
        return EntitlementsClient(
            entitlements_url=entitlements_url,
            config_manager=self.config,
            data_partition_id=self.data_partition_id,
            token_refresher=self.token_refresher
        )

    def get_wellbore_ddms_client(
        self,
        url_extra_path: str
    ) -> WellboreDdmsClient:
        """Get a client for the wellbore ddms service

        Args:
            url_extra_path (str): extra path to add to the base path
        """
        wellbore_ddms_url = self.url_from_config(CONFIG_WELLBORE_DDMS_URL, url_extra_path)
        return WellboreDdmsClient(
            wellbore_ddms_url=wellbore_ddms_url,
            config_manager=self.config,
            data_partition_id=self.data_partition_id,
            token_refresher=self.token_refresher
        )

    def cli_get(
        self,
        config_url_key: str,
        url_extra_path: str,
        ok_status_codes: list = None
    ) -> requests.Response:
        """Basic GET call to the given url, returning the response object.

        Args:
            config_url_key (str): key in configuration for the base path
            url_extra_path (str): extra path to add to the base path
            ok_status_codes (list, optional): Optional status codes to check for successful call.
        """
        url = self.url_from_config(config_url_key, url_extra_path)
        response = self.make_request(method=HttpMethod.GET, url=url)
        self.check_status_code(response, ok_status_codes)
        return response

    def cli_get_returning_json(
        self,
        config_url_key: str,
        url_extra_path: str,
        ok_status_codes: list = None
    ) -> dict:
        """Basic GET call to the given url, returning the json.

        Args:
            config_url_key (str): key in configuration for the base path
            url_extra_path (str): extra path to add to the base path
            ok_status_codes (list, optional): Status codes indicating successful call. Defaults to [200].
        """
        url = self.url_from_config(config_url_key, url_extra_path)
        response = self.make_request(method=HttpMethod.GET, url=url)
        self.check_status_code(response, ok_status_codes)
        return response.json()

    def cli_post_returning_json(
        self,
        config_url_key: str,
        url_extra_path: str,
        data: str | dict,
        ok_status_codes: list = None,
    ) -> dict:
        """Basic POST call to the given url, returning the json.

        Args:
            config_url_key (str): key in configuration for the base path
            url_extra_path (str): extra path to add to the base path
            data (Union[str, dict]): json data as string or dict to send as the body
            ok_status_codes (list, optional): Status codes indicating successful call. Defaults to [200].

        Returns:
            dict: returned json
        """
        url = self.url_from_config(config_url_key, url_extra_path)
        if isinstance(data, dict):
            data = json.dumps(data)
        response = self.make_request(method=HttpMethod.POST, url=url, data=data)
        self.check_status_code(response, ok_status_codes)
        return response.json()

    def cli_delete(
        self,
        config_url_key: str,
        url_extra_path: str,
        ok_status_codes: list = None,
    ) -> requests.Response:
        """Basic DELETE call to the given url.

        Args:
            config_url_key (str): key in configuration for the base path
            url_extra_path (str): extra path to add to the base path
            ok_status_codes (list, optional): Optional status codes to check for successful call.

        Returns:
            requests.Response: Response object from the HTTP call
        """
        url = self.url_from_config(config_url_key, url_extra_path)

        # TODO: Fix bug in SDK for DELETE. Workaround is to give bearer_token
        response = self.make_request(method=HttpMethod.DELETE, url=url,
                                     bearer_token=self.token_refresher.refresh_token())

        self.check_status_code(response, ok_status_codes)
        return response

    def cli_put(
        self,
        config_url_key: str,
        url_extra_path: str,
        data: str | dict,
        ok_status_codes: list = None,
    ) -> requests.Response:
        """Basic PUT call to the given url.

        Args:
            config_url_key (str): key in configuration for the base path
            url_extra_path (str): extra path to add to the base path
            data (Union[str, dict]): json data as string or dict to send as the body
            ok_status_codes (list, optional): Optional status codes to check for successful call.
        """
        url = self.url_from_config(config_url_key, url_extra_path)
        if isinstance(data, dict):
            data = json.dumps(data)
        response = self.make_request(method=HttpMethod.PUT, url=url, data=data)
        self.check_status_code(response, ok_status_codes)
        return response

    def cli_put_returning_json(
        self,
        config_url_key: str,
        url_extra_path: str,
        data: str | dict,
        ok_status_codes: list = None,
    ) -> dict:
        """Basic PUT call to the given url, returning the json.

        Args:
            config_url_key (str): key in configuration for the base path
            url_extra_path (str): extra path to add to the base path
            data (Union[str, dict]): data to send
            ok_status_codes (list, optional): accepted ok response codes. Defaults to [200].

        Returns:
            dict: returned json
        """
        url = self.url_from_config(config_url_key, url_extra_path)
        if isinstance(data, dict):
            data = json.dumps(data)
        response = self.make_request(method=HttpMethod.PUT, url=url, data=data)
        self.check_status_code(response, ok_status_codes)
        return response.json()
</file>

<file path="osducli/config.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Read and modify configuration settings related to the CLI"""

import configparser
import os
import re
import stat

from osdu_api.configuration.base_config_manager import BaseConfigManager

from osducli.util.file import ensure_directory_exists

_UNSET = object()


# Default names
CLI_NAME = "osducli"
CLI_CONFIG_DIR = os.path.expanduser(os.path.join("~", f".{CLI_NAME}"))
CLI_ENV_VAR_PREFIX = CLI_NAME

CONFIG_SERVER = "server"
CONFIG_CRS_CATALOG_URL = "crs_catalog_url"
CONFIG_CRS_CONVERTER_URL = "crs_converter_url"
CONFIG_ENTITLEMENTS_URL = "entitlements_url"
CONFIG_FILE_URL = "file_url"
CONFIG_LEGAL_URL = "legal_url"
CONFIG_SCHEMA_URL = "schema_url"
CONFIG_SEARCH_URL = "search_url"
CONFIG_STORAGE_URL = "storage_url"
CONFIG_UNIT_URL = "unit_url"
CONFIG_WORKFLOW_URL = "workflow_url"
CONFIG_WELLBORE_DDMS_URL = "wellbore_ddms_url"

CONFIG_DATA_PARTITION_ID = "data_partition_id"
CONFIG_LEGAL_TAG = "legal_tag"
CONFIG_ACL_VIEWER = "acl_viewer"
CONFIG_ACL_OWNER = "acl_owner"

CONFIG_AUTHENTICATION_MODE = "authentication_mode"

CONFIG_AUTHENTICATION_AUTHORITY = "authority"
CONFIG_AUTHENTICATION_SCOPES = "scopes"

CONFIG_TOKEN_ENDPOINT = "token_endpoint"
CONFIG_REFRESH_TOKEN = "refresh_token"
CONFIG_CLIENT_ID = "client_id"
CONFIG_CLIENT_SECRET = "client_secret"


class CLIConfig(BaseConfigManager):
    _BOOLEAN_STATES = {
        "1": True,
        "yes": True,
        "true": True,
        "on": True,
        "0": False,
        "no": False,
        "false": False,
        "off": False,
    }

    _DEFAULT_CONFIG_FILE_NAME = "config"
    _CONFIG_DEFAULTS_SECTION = "defaults"

    def __init__(
        self,
        config_dir,
        config_env_var_prefix,
        config_file_name=None,
    ):
        """Manages configuration options available in the CLI

        :param config_dir: The directory to store config files
        :type config_dir: str
        :param config_env_var_prefix: The prefix for config environment variables
        :type config_env_var_prefix: str
        :param config_file_name: The name given to the config file to be created
        :type config_file_name: str
        """
        # ensure_dir(config_dir)
        env_var_prefix = f"{config_env_var_prefix.upper()}_"
        default_config_dir = os.path.expanduser(config_dir)
        self.config_dir = os.environ.get(f"{env_var_prefix}CONFIG_DIR", default_config_dir)
        self.config_file_name = config_file_name or CLIConfig._DEFAULT_CONFIG_FILE_NAME
        self.config_path = os.path.join(self.config_dir, self.config_file_name)
        self._env_var_format = f"{env_var_prefix}{{section}}_{{option}}"
        self.defaults_section_name = CLIConfig._CONFIG_DEFAULTS_SECTION

        self.config_parser = configparser.ConfigParser()
        if os.path.exists(self.config_path):
            self.config_parser.read(self.config_path)

    def env_var_name(self, section, option):
        return self._env_var_format.format(section=section.upper(), option=option.upper())

    def has_option(self, section, option):
        if self.env_var_name(section, option) in os.environ:
            return True
        return self.config_parser.has_option(section, option) if self.config_parser else False

    def get(self, section, option, default=_UNSET):
        # Fall back to defaults section if section is not found
        if section not in self.sections():
            section = self.defaults_section_name
        env = self.env_var_name(section, option)
        if env in os.environ:
            return os.environ[env]
        last_ex = None
        try:
            if self.config_parser:
                return self.config_parser.get(section, option)
            raise configparser.NoOptionError(option, section)
        except (configparser.NoSectionError, configparser.NoOptionError) as ex:
            last_ex = ex

        if default is _UNSET:
            raise last_ex
        return default

    def sections(self):
        return self.config_parser.sections() if self.config_parser else []

    def items(self, section):
        # Only allow valid env vars, in all caps: CLI_SECTION_TEST_OPTION, CLI_SECTION__TEST_OPTION
        pattern = self.env_var_name(section, "([0-9A-Z_]+)")
        env_entries = []
        for k in os.environ:
            # Must be a full match, otherwise CLI_SECTION_T part in CLI_MYSECTION_Test_Option will match
            matched = re.fullmatch(pattern, k)
            if matched:
                # (name, value, ENV_VAR_NAME)
                item = (matched.group(1).lower(), os.environ[k], k)
                env_entries.append(item)

        # Prepare result with env entries first
        result = {c[0]: c for c in env_entries}
        # Add entries from config file if they do not exist yet
        try:
            entries = self.config_parser.items(section) if self.config_parser else []
            for name, value in entries:
                if name not in result:
                    result[name] = (name, value, self.config_path)
        except (configparser.NoSectionError, configparser.NoOptionError):
            pass
        return [
            {"name": name, "value": value, "source": source}
            for name, value, source in result.values()
        ]

    def getint(self, section, option, default=_UNSET):
        return int(self.get(section, option, default))

    def getfloat(self, section, option, default=_UNSET):
        return float(self.get(section, option, default))

    def getbool(self, section, option, default=_UNSET):
        val = str(self.get(section, option, default))
        if val.lower() not in CLIConfig._BOOLEAN_STATES:
            raise ValueError(f"Not a boolean: {val}")
        return CLIConfig._BOOLEAN_STATES[val.lower()]

    def set(self, config):
        ensure_directory_exists(self.config_dir)
        with open(self.config_path, "w", encoding="utf-8") as configfile:
            # if self.config_comment:
            #     configfile.write(self.config_comment + '\n')
            config.write(configfile)
        os.chmod(self.config_path, stat.S_IRUSR | stat.S_IWUSR)
        self.config_parser.read(self.config_path)

    def set_value(self, section, option, value):
        config = configparser.ConfigParser()
        config.read(self.config_path)
        try:
            config.add_section(section)
        except configparser.DuplicateSectionError:
            pass
        config.set(section, option, value)
        self.set(config)


def get_default_from_config(config, section, option, fallback=1):
    """Get the default value from configuration, replacing with fallback if not found"""
    try:
        return config.get(section, option)
    except (IndexError, configparser.NoSectionError, configparser.NoOptionError):
        return fallback


def get_default_choice_index_from_config(config, section, option, choice_list, fallback=1):
    """Get index + 1 of the current choice value from cong, replacing with fallback if not found"""
    try:
        config_val = config.get(section, option)
        return [i for i, x in enumerate(choice_list) if "name" in x and x["name"] == config_val][
            0
        ] + 1
    except (IndexError, configparser.NoSectionError, configparser.NoOptionError):
        return fallback
</file>

<file path="osducli/log.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Read and modify configuration settings related to the CLI"""

import logging
from enum import IntEnum

CLI_LOGGER_NAME = "cli"
# Add more logger names to this list so that ERROR, WARNING, INFO logs from these loggers can also be displayed
# without --debug flag.
cli_logger_names = [CLI_LOGGER_NAME]

LOG_FILE_ENCODING = "utf-8"


class CliLogLevel(IntEnum):
    """[summary]

    Args:
        IntEnum ([type]): [description]
    """

    CRITICAL = 0
    ERROR = 1
    WARNING = 2
    INFO = 3
    DEBUG = 4


def get_logger(module_name=None):
    """Get the logger for a module. If no module name is given, the current CLI logger is returned.

    Example:
        get_logger(__name__)

    :param module_name: The module to get the logger for
    :type module_name: str
    :return: The logger
    :rtype: logger
    """
    if module_name:
        logger_name = f"{CLI_LOGGER_NAME}.{module_name}"
    else:
        logger_name = CLI_LOGGER_NAME
    return logging.getLogger(logger_name)
</file>

<file path="osducli/state.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Read and modify state related to the CLI"""

import os
from os import path

from osducli.config import CLI_CONFIG_DIR, CLI_ENV_VAR_PREFIX, CLI_NAME, CLIConfig

# CLIConfig has all the functionality needed to keep track of state, so we are using that
# here to prevent code duplication. We are using CLIConfig to create a file called 'state' to
# track states associated with osducli, such as the last time osducli version was checked.

# Default names
CLI_STATE_DIR = os.path.expanduser(os.path.join("~", f".{CLI_NAME}"))
STATE_FILE_NAME = "state"

# Format: Year, month, day, hour, minute, second, microsecond
DATETIME_FORMAT = "Year %Y Month %m Day %d %H:%M:%S:%f"


def get_state_path():
    """
    Returns the path of where the state file of osducli is stored.
    :return: str
    """

    return CLIConfig(CLI_STATE_DIR, CLI_ENV_VAR_PREFIX, STATE_FILE_NAME).config_path


def get_state_value(name, fallback=None):
    """Gets a state entry by name.

    In the case where the state entry name is not found, will use fallback value."""

    cli_config = CLIConfig(CLI_STATE_DIR, CLI_ENV_VAR_PREFIX, STATE_FILE_NAME)

    return cli_config.get("core", name, fallback)


def set_state_value(name, value):
    """
    Set a state entry with a specified a value.

    Args:
        name (str): Name of the state.
        value (str): Value of the state.
    """
    cli_config = CLIConfig(CLI_STATE_DIR, CLI_ENV_VAR_PREFIX, STATE_FILE_NAME)
    cli_config.set_value("core", name, value)


def get_default_config_path(locate: bool = False) -> str:
    """Get the path of the default config file.

    Args:
        locate (bool): Whether to try and locate the default config file. Defaults to False

    Returns:
        str: Path to config, or None if not in state
    """
    config_path = get_state_value("default_config")
    if not config_path and locate:
        config_path = CLIConfig(CLI_CONFIG_DIR, CLI_ENV_VAR_PREFIX).config_path  # noqa: E501 pylint:disable=redefined-variable-type
    return config_path


def get_default_config(locate: bool = False) -> CLIConfig:
    """Get the path of the default config file.

    Args:
        locate (bool): Whether to try and locate the default config file. Defaults to False

    Returns:
        CLIConfig: CLIConfig, or None if nothing found / set
    """
    default_config = get_default_config_path(locate)
    default_config_path, default_config_file = path.split(default_config)
    return CLIConfig(default_config_path, CLI_ENV_VAR_PREFIX, default_config_file)


def set_default_config_path(default_config: str = None):
    """Set the default config file.

    Args:
        default_config (str, optional): path of default config file. Defaults to None.
    """
    set_state_value("default_config", default_config)
</file>

<file path="osducli/wbddms_client.py">
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Client for Wellbore DDMS API in the template of osdu-api clients"""

import requests
from osdu_api.auth.authorization import TokenRefresher
from osdu_api.clients.base_client import BaseClient
from osdu_api.configuration.base_config_manager import BaseConfigManager
from osdu_api.model.http_method import HttpMethod

from osducli.log import get_logger

logger = get_logger(__name__)


class WellboreDdmsClient(BaseClient):
    """
    Client for interacting with Wellbore DDMS
    """
    def __init__(
            self,
            wellbore_ddms_url: str = None,
            config_manager: BaseConfigManager = None,
            provider: str = None,
            data_partition_id: str = None,
            token_refresher: TokenRefresher = None,
            user_id: str = None
    ):
        super().__init__(config_manager, provider, data_partition_id, token_refresher, logger, user_id)
        self.wellbore_ddms_url = wellbore_ddms_url or self.config_manager.get('environment', 'wellbore_ddms_url')

    def get_well_log(self, record_id: str = None) -> requests.Response:
        """Get wellLog record from wellbore ddms by id"""
        return self.make_request(method=HttpMethod.GET, url=f'{self.wellbore_ddms_url}/{record_id}')

    def create_well_log(self, record_data_list: str = None) -> requests.Response:
        """Create wellLog record with wellbore ddms"""
        return self.make_request(method=HttpMethod.POST, url=self.wellbore_ddms_url, data=record_data_list)

    def get_well_log_data(self, record_id: str) -> requests.Response:
        """Get wellLog composite parquet from wellbore ddms"""
        return self.make_request(method=HttpMethod.GET, url=f'{self.wellbore_ddms_url}/{record_id}/data')

    def create_well_log_data(self, record_id: str, data: str = '') -> requests.Response:
        """Create wellLog composite parquet with wellbore ddms"""
        additional_header = {'Content-Type': 'application/x-parquet'}
        return self.make_request(method=HttpMethod.POST, url=f'{self.wellbore_ddms_url}/{record_id}/data',
                                 add_headers=additional_header, data=data)
</file>

</files>
